function [signal state] = flt_interpchs(varargin)
%
% Automatic corregistration of an individual montage to a template, it uses
% a common set of landmarks to estimate the affine mapping from the
% individual space to the template.
% 
% Input:
%  scalpmaps:           Nsensors x Nscalpmaps to be corregistered
%  xyzSensors:          Nsensors x 3 with the sensor locations in world coordinates
%  landmarkCoordinates: Nlandmarks x 3 coordinates of the points used for matching individual and template spaces
%  landmarkLabels:      Nlandmarks x 1 cell array of strings with the label of each landmar
%
% Output:
%  scalpmaps:  spatialy resampled scalpmaps (if is needed)
%  xyzSensors: warped individual montage
%
% See also: headModel, geometricTools, variationalDynLoreta
% For more details visit https://code.google.com/p/mobilab/
%
% Author: Alejandro Ojeda, SCCN/INC/UCSD, Mar-2013
% extract some defaults

if ~exp_beginfun('filter'), return; end

declare_properties('name','ChannelInterpolation', 'experimental',true, 'follows',{'flt_selchans','flt_clean_settings'},'follows',{'flt_reref'},'cannot_follow',{'set_makepos'},'independent_channels',false, 'independent_trials',false);

headmodel_default = 'resources:/headmodels/standard-Colin27-385ch.mat';
% if ~onl_isonline
%     hmObj = arg_extract(varargin,{'hmObj','HeadModelObject'},[],headmodel_default);
%     hmObj = hlp_validateHeadModelObject(hmObj);
% end

state = [];
arg_define(varargin, ...
    arg_norep({'signal','Signal'},[],[],'Signal structure. Must contain .data field with channel data'), ...
    arg({'hmObj','TemplateHeadModel','HeadModelObject'},headmodel_default,[],'Head model object generated by MOBILAB. See MOBILAB''s headModel class.'), ...
    arg({'verb','Verbosity'},false,[],'Verbose output'), ...
    arg_nogui({'state','State'},unassigned));

%     arg({'landmarkCoordinates','LandmarkCoordinates'},[],[],'Landmark coordinates [nchs x 3]. These are at least 3 electrode locations in both the template model and signal.chanlocs, used for coregistration'), ...

hmObj = hlp_validateHeadModelObject(hmObj);

if size(hmObj.channelSpace,1) == signal.nbchan
    return;
end

if ~exist('state','var') || isempty(state)
   % construct state
    
    % get current sensor locations
    xyzSensors = [[signal.chanlocs.X]' [signal.chanlocs.Y]' [signal.chanlocs.Z]'];
    
    [~,loc1,loc2] = intersect(lower(hmObj.getChannelLabels),lower({signal.chanlocs.labels}));
    if isempty(loc1), error('Cannot find a match between the landmarks and the template model channels.');end
    T = hmObj.channelSpace(loc1,:);
    S = xyzSensors(loc2,:);

    % affine coregistration at scalp level
    Aff = geometricTools.affineMapping(S,T);
    xyzSensors = geometricTools.applyAffineMapping(xyzSensors, Aff);
                
    if ~isempty(which('bspline_trans_points_double'))
        S = xyzSensors;
        T = hmObj.channelSpace;
        [S,d] = geometricTools.nearestNeighbor(S, T);
        z = zscore(d);
        th = norminv(0.90);
        S(abs(z)>th,:) = [];
        T(abs(z)>th,:) = [];
        options.Verbose = verb;
        options.MaxRef = 2;
        [Def,spacing,offset] = geometricTools.bSplineMapping(S,T,S,options);
        xyzSensors = geometricTools.applyBSplineMapping(Def,spacing,offset,xyzSensors);
    else
        if verb
            disp('Affine corregistration is not always enough, for a second step bspline corregistration add to the path: ''.../mobilab/dependency/nonrigid_version23'' ');
        end
    end

    % Gaussian kernel interpolation
    state.interpmat = geometricTools.localGaussianInterpolator(xyzSensors,hmObj.channelSpace,3);
    state.interpmat = full(state.interpmat);
    
    % reconstruct chanlocs
    targ_nchs = size(hmObj.channelSpace,1);
    chanlocs = repmat(struct('labels',[],'type',[],'X',[],'Y',[],'Z',[],'radius',[],'theta',[]),targ_nchs,1);
    labels = hmObj.getChannelLabels;
    for it=1:targ_nchs
        chanlocs(it).labels = labels{it};
        chanlocs(it).type = 'EEG';
        
        chanlocs(it).X = hmObj.channelSpace(it,2);
        chanlocs(it).Y = hmObj.channelSpace(it,1);
        chanlocs(it).Z = hmObj.channelSpace(it,3);
        [chanlocs(it).theta,chanlocs(it).radius] = cart2pol(hmObj.channelSpace(it,1), hmObj.channelSpace(it,2), ...
            hmObj.channelSpace(it,3));
        chanlocs(it).theta = -chanlocs(it).theta*180/pi;
    end
    state.chanlocs = chanlocs;

end

% perform interpolation
signal.data     = state.interpmat*signal.data;
signal.nbchan   = size(signal.data,1);
signal.chanlocs = state.chanlocs;


exp_endfun;