<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of arg_define</title>
  <meta name="keywords" content="arg_define">
  <meta name="description" content="Declare function arguments with optional defaults and built-in GUI support.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">code</a> &gt; <a href="index.html">arguments</a> &gt; arg_define.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for code/arguments&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>arg_define
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Declare function arguments with optional defaults and built-in GUI support.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function res = arg_define(vals,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Declare function arguments with optional defaults and built-in GUI support.
 Struct = arg_define(Values, Specification...)
 Struct = arg_define(Format, Values, Specification...)

 This is essentially an improved replacement for the parameter declaration line of a function.
 Assigns Values (a cell array of values, typically the &quot;varargin&quot; of the calling function,
 henceforth named the &quot;Function&quot;) to fields in the output Struct, with parsing implemented
 according to a Specification of argument names and their order (optionally with a custom argument
 Format description).

 By default, values can be a list of a fixed number of positional arguments (i.e., the typical
 MATLAB calling format), optionally followed by a list of name-value pairs (NVPs, e.g., as the
 format accepted by figure()), in which, as well, instead of any given NVP, a struct may be
 passed (thus, one may pass a mix of 'name',value,struct,'name',value,'name',value, ...
 parameters). Alternatively, by default the entire list of positional arguments can instead be be
 specified as a list of NVPs/structs. Only names that are allowed by the Specification may be used,
 if positional syntax is allowed by the Format (which is the default).

 The special feature over hlp_varargin2struct()-like functionality is that arguments defined via
 arg_define can be reported to outside functions (if triggered by arg_report()). The resulting
 specification can be rendered in a GUI or be processed otherwise.

 In:
   Format : Optional format description (default: [0 Inf]):
            * If this is a number (say, k), it indicates that the first k arguments are specified
              in a positional manner, and the following arguments are specified as list of
              name-value pairs and/or structs.
            * If this is a vector of two numbers [0 k], it indicates that the first k arguments MAY
              be specified in a positional manner (the following arguments must be be specified as
              NVPs/structs) OR alternatively, all arguments can be specified as NVPs / structs.
              Only names that are listed in the specification may be used as names (in NVPs and
              structs) in this case.
            * If this is a function handle, the function is used to transform the Values prior to
              any other processing into a new Values cell array. The function may specify a new
              (numeric) Format as its second output argument (if not specified, this is 0).

   Values : A cell array of values passed to the function (usually the calling function's
            &quot;varargin&quot;). Interpreted according to the Format and the Specification.

   Specification... : The specification of the calling function's arguments; this is a sequence of
                      arg(), arg_norep(), arg_nogui(), arg_sub(), arg_subswitch(), arg_subtoggle()
                      specifiers. The special keywords mandatory and unassigned can be used in the
                      declaration of default values, where &quot;mandatory&quot; declares that this argument
                      must be assigned some value via Values (otherwise, an error is raised before
                      the arg is passed to the Function) and &quot;unassigned&quot; declares that the
                      variable will not be assigned unless passed as an argument (akin to the
                      default behavior of regular MATLAB function arguments).

 Out:
   Struct : A struct with values assigned to fields, according to the Specification and Format.

            If this is not captured by the Function in a variable, the contents of Struct are
            instead assigned to the Function's workspace (default practice) -- but note that this
            only works for variable names are *not&amp; also names of functions in the path (due to a
            flaw in MATLAB's treatment of identifiers). Thus, it is good advice to use long/expressive
            variable names to avoid this situation, or possibly CamelCase names.

 See also:
   <a href="arg.html" class="code" title="function res = arg(varargin)">arg</a>, <a href="arg_nogui.html" class="code" title="function res = arg_nogui(varargin)">arg_nogui</a>, <a href="arg_norep.html" class="code" title="function res = arg_norep(varargin)">arg_norep</a>, <a href="arg_sub.html" class="code" title="function res = arg_sub(varargin)">arg_sub</a>, <a href="arg_subswitch.html" class="code" title="function res = arg_subswitch(varargin)">arg_subswitch</a>, <a href="arg_subtoggle.html" class="code" title="function res = arg_subtoggle(varargin)">arg_subtoggle</a>

 Notes:
   1) If the Struct output argument is omitted by the user, the arguments are not returned as a
      struct but instead directly copied into the Function's workspace.

   2) Someone may call the user's Function with the request to deliver the parameter specification,
      instead of following the normal execution flow. arg_define() automatically handles this task
      by throwing an exception of the type 'BCILAB:arg:report_args' using arg_issuereport(), which
      is to be caught by the requesting function.

 Performance Tips:
   1) If a struct with a field named 'arg_direct' is passed (and is set to true), or a name-value
      pair 'arg_direct',true is passed, then all type checking, specification parsing, fallback to
      default values and reporting functionality are skipped. This is a fast path to call a function,
      and it usually requires that all of its arguments are passed. The function <a href="arg_report.html" class="code" title="function res = arg_report(type,func,args)">arg_report</a> allows
      to get a struct of all function arguments that can be used subsequently as part of a direct
      call.

      Please make sure not to pass multiple occurrences of 'arg_direct' with conflicting values to
      <a href="arg_define.html" class="code" title="function res = arg_define(vals,varargin)">arg_define</a>, as the behavior will then be undefined.

   2) The function is about 2x as fast (in direct mode) if arguments are returned as a struct instead
      of being written into the caller's workspace.

 Examples:
   function myfunction(varargin)

   % begin a default argument declaration and declare a few arguments; The arguments can be passed either:
   % - by position: myfunction(4,20); including the option to leave some values at their defaults, e.g. myfunction(4) or myfunction()
   % - by name: myfunction('test',4,'blah',20); myfunction('blah',21,'test',4); myfunction('blah',22);
   % - as a struct: myfunction(struct('test',4,'blah',20))
   % - as a sequence of either name-value pairs or structs: myfunction('test',4,struct('blah',20)) (note that this is not ambiguous, as the struct would come in a place where only a name could show up otherwise
   arg_define(varargin, ...
       arg('test',3,[],'A test.'), ...
       arg('blah',25,[],'Blah.'));

   % a special syntax that is allowed is passing a particular parameter multiple times - in which case only the last specification is effective
   % myfunction('test',11, 'blah',21, 'test',3, struct('blah',15,'test',5), 'test',10) --&gt; test will be 10, blah will be 15

   % begin an argument declaration which allows 0 positional arguments (i.e. everything must be passed by name
   arg_define(0,varargin, ...

   % begin an argument declaration which allows exactly 1 positional arguments, i.e. the first one must be passed by position and the other one by name (or struct)
   % valid calls would be: myfunction(3,'blah',25); myfunction(3); myfunction(); (the last one assumes the default for both)
   arg_define(1,varargin, ...
       arg('test',3,[],'A test.'), ...
       arg('blah',25,[],'Blah.'));

   % begin an argument decalration which allows either 2 positional arguments or 0 positional arguments (i.e. either the first two are passed by position, or all are passed by name)
   % some valid calls are: myfunction(4,20,'flag',true); myfunction(4,20); myfunction(4,20,'xyz','test','flag',true); myfunction(4); myfunction('flag',true,'test',4,'blah',21); myfunction('flag',true)
   arg_define([0 2],varargin, ...
       arg('test',3,[],'A test.'), ...
       arg('blah',25,[],'Blah.'), ...
       arg('xyz','defaultstr',[],'XYZ.'), ...
       arg('flag',false,[],'Some flag.'));

   % begin an argument declaration in which the formatting of arguments is completely arbitrary, and a custom function takes care of bringing them into a form understood by
   % the <a href="arg_define.html" class="code" title="function res = arg_define(vals,varargin)">arg_define</a> implementation. This function takes a cell array of arguments (in any formatting), and returns a cell array of a standard formatting (e.g. name-value pairs, or structs)
   arg_define(@myparser,varargin, ...
       arg('test',3,[],'A test.'), ...
       arg('blah',25,[],'Blah.'));

   % return the arguments as fields in a struct (here: opts), instead of directly in the workspace
   opts = arg_define(varargin, ...
       arg('test',3,[],'A test.'), ...
       arg('blah',25,[],'Blah.'));

   % note: in the current implementation, the only combinations of allowed argument numbers are: arg_define(...); arg_define(0, ...); arg_define(X, ...); arg_define([0 X], ...); arg_define(@somefunc, ...);
   %       the implicit default is arg_define([0 Inf], ...)

                                Christian Kothe, Swartz Center for Computational Neuroscience, UCSD
                                2010-09-24</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="arg_issuereport.html" class="code" title="function arg_issuereport(payload)">arg_issuereport</a>	Internal function to issue a report to a requesting function.</li><li><a href="arg_nogui.html" class="code" title="function res = arg_nogui(varargin)">arg_nogui</a>	Like arg(), but not displayed by GUIs.</li><li><a href="arg_specifier.html" class="code" title="function spec = arg_specifier(varargin)">arg_specifier</a>	Internal: create a base specifier struct for an argument.</li><li><a href="arg_tovals.html" class="code" title="function res = arg_tovals(spec,direct)">arg_tovals</a>	Convert a 'rich' argument report into a 'vals' report.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="arg_sub.html" class="code" title="function res = arg_sub(varargin)">arg_sub</a>	Specify an argument of a function which is a structure of sub-arguments.</li><li><a href="arg_subswitch.html" class="code" title="function res = arg_subswitch(varargin)">arg_subswitch</a>	Specify a function argument that can be one of several alternative structs.</li><li><a href="arg_subtoggle.html" class="code" title="function res = arg_subtoggle(varargin)">arg_subtoggle</a>	Specify an argument of a function which is a struct of sub-arguments that can be disabled.</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function args = flatten_structs(args)</a></li><li><a href="#_sub2" class="code">function [spec,all_names,joint_names,remap] = evaluate_spec(spec,reporting_type,require_namecheck)</a></li><li><a href="#_sub3" class="code">function check_names(code_names)</a></li><li><a href="#_sub4" class="code">function_caller = hlp_getcaller(4);</a></li><li><a href="#_sub5" class="code">function_caller = hlp_getcaller(14); end</a></li><li><a href="#_sub6" class="code">function r = find_function(spec,name)</a></li><li><a href="#_sub7" class="code">function f = find_function_cached(spec,name)</a></li><li><a href="#_sub8" class="code">function x = format_cellstr(x)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function res = arg_define(vals,varargin)</a>
0002 <span class="comment">% Declare function arguments with optional defaults and built-in GUI support.</span>
0003 <span class="comment">% Struct = arg_define(Values, Specification...)</span>
0004 <span class="comment">% Struct = arg_define(Format, Values, Specification...)</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% This is essentially an improved replacement for the parameter declaration line of a function.</span>
0007 <span class="comment">% Assigns Values (a cell array of values, typically the &quot;varargin&quot; of the calling function,</span>
0008 <span class="comment">% henceforth named the &quot;Function&quot;) to fields in the output Struct, with parsing implemented</span>
0009 <span class="comment">% according to a Specification of argument names and their order (optionally with a custom argument</span>
0010 <span class="comment">% Format description).</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% By default, values can be a list of a fixed number of positional arguments (i.e., the typical</span>
0013 <span class="comment">% MATLAB calling format), optionally followed by a list of name-value pairs (NVPs, e.g., as the</span>
0014 <span class="comment">% format accepted by figure()), in which, as well, instead of any given NVP, a struct may be</span>
0015 <span class="comment">% passed (thus, one may pass a mix of 'name',value,struct,'name',value,'name',value, ...</span>
0016 <span class="comment">% parameters). Alternatively, by default the entire list of positional arguments can instead be be</span>
0017 <span class="comment">% specified as a list of NVPs/structs. Only names that are allowed by the Specification may be used,</span>
0018 <span class="comment">% if positional syntax is allowed by the Format (which is the default).</span>
0019 <span class="comment">%</span>
0020 <span class="comment">% The special feature over hlp_varargin2struct()-like functionality is that arguments defined via</span>
0021 <span class="comment">% arg_define can be reported to outside functions (if triggered by arg_report()). The resulting</span>
0022 <span class="comment">% specification can be rendered in a GUI or be processed otherwise.</span>
0023 <span class="comment">%</span>
0024 <span class="comment">% In:</span>
0025 <span class="comment">%   Format : Optional format description (default: [0 Inf]):</span>
0026 <span class="comment">%            * If this is a number (say, k), it indicates that the first k arguments are specified</span>
0027 <span class="comment">%              in a positional manner, and the following arguments are specified as list of</span>
0028 <span class="comment">%              name-value pairs and/or structs.</span>
0029 <span class="comment">%            * If this is a vector of two numbers [0 k], it indicates that the first k arguments MAY</span>
0030 <span class="comment">%              be specified in a positional manner (the following arguments must be be specified as</span>
0031 <span class="comment">%              NVPs/structs) OR alternatively, all arguments can be specified as NVPs / structs.</span>
0032 <span class="comment">%              Only names that are listed in the specification may be used as names (in NVPs and</span>
0033 <span class="comment">%              structs) in this case.</span>
0034 <span class="comment">%            * If this is a function handle, the function is used to transform the Values prior to</span>
0035 <span class="comment">%              any other processing into a new Values cell array. The function may specify a new</span>
0036 <span class="comment">%              (numeric) Format as its second output argument (if not specified, this is 0).</span>
0037 <span class="comment">%</span>
0038 <span class="comment">%   Values : A cell array of values passed to the function (usually the calling function's</span>
0039 <span class="comment">%            &quot;varargin&quot;). Interpreted according to the Format and the Specification.</span>
0040 <span class="comment">%</span>
0041 <span class="comment">%   Specification... : The specification of the calling function's arguments; this is a sequence of</span>
0042 <span class="comment">%                      arg(), arg_norep(), arg_nogui(), arg_sub(), arg_subswitch(), arg_subtoggle()</span>
0043 <span class="comment">%                      specifiers. The special keywords mandatory and unassigned can be used in the</span>
0044 <span class="comment">%                      declaration of default values, where &quot;mandatory&quot; declares that this argument</span>
0045 <span class="comment">%                      must be assigned some value via Values (otherwise, an error is raised before</span>
0046 <span class="comment">%                      the arg is passed to the Function) and &quot;unassigned&quot; declares that the</span>
0047 <span class="comment">%                      variable will not be assigned unless passed as an argument (akin to the</span>
0048 <span class="comment">%                      default behavior of regular MATLAB function arguments).</span>
0049 <span class="comment">%</span>
0050 <span class="comment">% Out:</span>
0051 <span class="comment">%   Struct : A struct with values assigned to fields, according to the Specification and Format.</span>
0052 <span class="comment">%</span>
0053 <span class="comment">%            If this is not captured by the Function in a variable, the contents of Struct are</span>
0054 <span class="comment">%            instead assigned to the Function's workspace (default practice) -- but note that this</span>
0055 <span class="comment">%            only works for variable names are *not&amp; also names of functions in the path (due to a</span>
0056 <span class="comment">%            flaw in MATLAB's treatment of identifiers). Thus, it is good advice to use long/expressive</span>
0057 <span class="comment">%            variable names to avoid this situation, or possibly CamelCase names.</span>
0058 <span class="comment">%</span>
0059 <span class="comment">% See also:</span>
0060 <span class="comment">%   arg, arg_nogui, arg_norep, arg_sub, arg_subswitch, arg_subtoggle</span>
0061 <span class="comment">%</span>
0062 <span class="comment">% Notes:</span>
0063 <span class="comment">%   1) If the Struct output argument is omitted by the user, the arguments are not returned as a</span>
0064 <span class="comment">%      struct but instead directly copied into the Function's workspace.</span>
0065 <span class="comment">%</span>
0066 <span class="comment">%   2) Someone may call the user's Function with the request to deliver the parameter specification,</span>
0067 <span class="comment">%      instead of following the normal execution flow. arg_define() automatically handles this task</span>
0068 <span class="comment">%      by throwing an exception of the type 'BCILAB:arg:report_args' using arg_issuereport(), which</span>
0069 <span class="comment">%      is to be caught by the requesting function.</span>
0070 <span class="comment">%</span>
0071 <span class="comment">% Performance Tips:</span>
0072 <span class="comment">%   1) If a struct with a field named 'arg_direct' is passed (and is set to true), or a name-value</span>
0073 <span class="comment">%      pair 'arg_direct',true is passed, then all type checking, specification parsing, fallback to</span>
0074 <span class="comment">%      default values and reporting functionality are skipped. This is a fast path to call a function,</span>
0075 <span class="comment">%      and it usually requires that all of its arguments are passed. The function arg_report allows</span>
0076 <span class="comment">%      to get a struct of all function arguments that can be used subsequently as part of a direct</span>
0077 <span class="comment">%      call.</span>
0078 <span class="comment">%</span>
0079 <span class="comment">%      Please make sure not to pass multiple occurrences of 'arg_direct' with conflicting values to</span>
0080 <span class="comment">%      arg_define, as the behavior will then be undefined.</span>
0081 <span class="comment">%</span>
0082 <span class="comment">%   2) The function is about 2x as fast (in direct mode) if arguments are returned as a struct instead</span>
0083 <span class="comment">%      of being written into the caller's workspace.</span>
0084 <span class="comment">%</span>
0085 <span class="comment">% Examples:</span>
0086 <span class="comment">%   function myfunction(varargin)</span>
0087 <span class="comment">%</span>
0088 <span class="comment">%   % begin a default argument declaration and declare a few arguments; The arguments can be passed either:</span>
0089 <span class="comment">%   % - by position: myfunction(4,20); including the option to leave some values at their defaults, e.g. myfunction(4) or myfunction()</span>
0090 <span class="comment">%   % - by name: myfunction('test',4,'blah',20); myfunction('blah',21,'test',4); myfunction('blah',22);</span>
0091 <span class="comment">%   % - as a struct: myfunction(struct('test',4,'blah',20))</span>
0092 <span class="comment">%   % - as a sequence of either name-value pairs or structs: myfunction('test',4,struct('blah',20)) (note that this is not ambiguous, as the struct would come in a place where only a name could show up otherwise</span>
0093 <span class="comment">%   arg_define(varargin, ...</span>
0094 <span class="comment">%       arg('test',3,[],'A test.'), ...</span>
0095 <span class="comment">%       arg('blah',25,[],'Blah.'));</span>
0096 <span class="comment">%</span>
0097 <span class="comment">%   % a special syntax that is allowed is passing a particular parameter multiple times - in which case only the last specification is effective</span>
0098 <span class="comment">%   % myfunction('test',11, 'blah',21, 'test',3, struct('blah',15,'test',5), 'test',10) --&gt; test will be 10, blah will be 15</span>
0099 <span class="comment">%</span>
0100 <span class="comment">%   % begin an argument declaration which allows 0 positional arguments (i.e. everything must be passed by name</span>
0101 <span class="comment">%   arg_define(0,varargin, ...</span>
0102 <span class="comment">%</span>
0103 <span class="comment">%   % begin an argument declaration which allows exactly 1 positional arguments, i.e. the first one must be passed by position and the other one by name (or struct)</span>
0104 <span class="comment">%   % valid calls would be: myfunction(3,'blah',25); myfunction(3); myfunction(); (the last one assumes the default for both)</span>
0105 <span class="comment">%   arg_define(1,varargin, ...</span>
0106 <span class="comment">%       arg('test',3,[],'A test.'), ...</span>
0107 <span class="comment">%       arg('blah',25,[],'Blah.'));</span>
0108 <span class="comment">%</span>
0109 <span class="comment">%   % begin an argument decalration which allows either 2 positional arguments or 0 positional arguments (i.e. either the first two are passed by position, or all are passed by name)</span>
0110 <span class="comment">%   % some valid calls are: myfunction(4,20,'flag',true); myfunction(4,20); myfunction(4,20,'xyz','test','flag',true); myfunction(4); myfunction('flag',true,'test',4,'blah',21); myfunction('flag',true)</span>
0111 <span class="comment">%   arg_define([0 2],varargin, ...</span>
0112 <span class="comment">%       arg('test',3,[],'A test.'), ...</span>
0113 <span class="comment">%       arg('blah',25,[],'Blah.'), ...</span>
0114 <span class="comment">%       arg('xyz','defaultstr',[],'XYZ.'), ...</span>
0115 <span class="comment">%       arg('flag',false,[],'Some flag.'));</span>
0116 <span class="comment">%</span>
0117 <span class="comment">%   % begin an argument declaration in which the formatting of arguments is completely arbitrary, and a custom function takes care of bringing them into a form understood by</span>
0118 <span class="comment">%   % the arg_define implementation. This function takes a cell array of arguments (in any formatting), and returns a cell array of a standard formatting (e.g. name-value pairs, or structs)</span>
0119 <span class="comment">%   arg_define(@myparser,varargin, ...</span>
0120 <span class="comment">%       arg('test',3,[],'A test.'), ...</span>
0121 <span class="comment">%       arg('blah',25,[],'Blah.'));</span>
0122 <span class="comment">%</span>
0123 <span class="comment">%   % return the arguments as fields in a struct (here: opts), instead of directly in the workspace</span>
0124 <span class="comment">%   opts = arg_define(varargin, ...</span>
0125 <span class="comment">%       arg('test',3,[],'A test.'), ...</span>
0126 <span class="comment">%       arg('blah',25,[],'Blah.'));</span>
0127 <span class="comment">%</span>
0128 <span class="comment">%   % note: in the current implementation, the only combinations of allowed argument numbers are: arg_define(...); arg_define(0, ...); arg_define(X, ...); arg_define([0 X], ...); arg_define(@somefunc, ...);</span>
0129 <span class="comment">%   %       the implicit default is arg_define([0 Inf], ...)</span>
0130 <span class="comment">%</span>
0131 <span class="comment">%                                Christian Kothe, Swartz Center for Computational Neuroscience, UCSD</span>
0132 <span class="comment">%                                2010-09-24</span>
0133 
0134 <span class="comment">% Copyright (C) Christian Kothe, SCCN, 2010, christian@sccn.ucsd.edu</span>
0135 <span class="comment">%</span>
0136 <span class="comment">% This program is free software; you can redistribute it and/or modify it under the terms of the GNU</span>
0137 <span class="comment">% General Public License as published by the Free Software Foundation; either version 2 of the</span>
0138 <span class="comment">% License, or (at your option) any later version.</span>
0139 <span class="comment">%</span>
0140 <span class="comment">% This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without</span>
0141 <span class="comment">% even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
0142 <span class="comment">% General Public License for more details.</span>
0143 <span class="comment">%</span>
0144 <span class="comment">% You should have received a copy of the GNU General Public License along with this program; if not,</span>
0145 <span class="comment">% write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307</span>
0146 <span class="comment">% USA</span>
0147 
0148 
0149 <span class="comment">% --- get Format, Values and Specification ---</span>
0150 
0151 <span class="keyword">if</span> iscell(vals)
0152     <span class="comment">% no Format specifier was given: use default</span>
0153     fmt = [0 Inf];
0154     spec = varargin;
0155     <span class="keyword">try</span>
0156         <span class="comment">% quick checks for direct (fast) mode</span>
0157         <span class="keyword">if</span> isfield(vals{end},<span class="string">'arg_direct'</span>)
0158             direct_mode = vals{end}.arg_direct;
0159         <span class="keyword">elseif</span> strcmp(vals{1},<span class="string">'arg_direct'</span>)
0160             direct_mode = vals{2};
0161         <span class="keyword">else</span>
0162             <span class="comment">% figure it out later</span>
0163             direct_mode = false;
0164         <span class="keyword">end</span>
0165         structs = cellfun(<span class="string">'isclass'</span>,vals,<span class="string">'struct'</span>);
0166     <span class="keyword">catch</span>
0167         <span class="comment">% vals was empty: default behavior</span>
0168         direct_mode = false;            
0169     <span class="keyword">end</span>
0170 <span class="keyword">else</span>
0171     <span class="comment">% a Format specifier was given as the first argument (instead of vals as the first argument) ...</span>
0172     <span class="keyword">if</span> isempty(vals)
0173         <span class="comment">% ... but it was empty: use default behavior</span>
0174         fmt = [0 Inf];
0175     <span class="keyword">else</span>
0176         <span class="comment">% ... and was nonempty: use it</span>
0177         fmt = vals;
0178     <span class="keyword">end</span>
0179     <span class="comment">% shift the remaining two args</span>
0180     vals = varargin{1};
0181     spec = varargin(2:end);
0182     <span class="keyword">if</span> isa(fmt,<span class="string">'function_handle'</span>)
0183         <span class="comment">% Format was a function: run it</span>
0184         <span class="keyword">if</span> nargout(fmt) == 1
0185             vals = fmt(vals);
0186             fmt = 0;
0187         <span class="keyword">else</span>
0188             [vals,fmt] = feval(fmt,vals);
0189         <span class="keyword">end</span>
0190     <span class="keyword">end</span>
0191     direct_mode = false;
0192 <span class="keyword">end</span>
0193 
0194 
0195 <span class="comment">% --- if not yet known, determine conclusively if we are in direct mode (specificationless and therefore fast) ---</span>
0196 
0197 <span class="comment">% this mode is only applicable when all arguments can be passed as NVPs/structs</span>
0198 <span class="keyword">if</span> ~direct_mode &amp;&amp; any(fmt == 0)
0199     <span class="comment">% search for an arg_direct argument</span>
0200     structs = cellfun(<span class="string">'isclass'</span>,vals,<span class="string">'struct'</span>);
0201     indices = find(structs | strcmp(vals,<span class="string">'arg_direct'</span>));
0202     <span class="keyword">for</span> k = indices(end:-1:1)
0203         <span class="keyword">if</span> ischar(vals{k}) &amp;&amp; k&lt;length(vals)
0204             <span class="comment">% found it in the NVPs</span>
0205             direct_mode = vals{k+1};
0206             <span class="keyword">break</span>;
0207         <span class="keyword">elseif</span> isfield(vals{k},<span class="string">'arg_direct'</span>)
0208             <span class="comment">% found it in a struct</span>
0209             direct_mode = vals{k}.arg_direct;
0210             <span class="keyword">break</span>;
0211         <span class="keyword">end</span>
0212     <span class="keyword">end</span>
0213 <span class="keyword">end</span>
0214 
0215 <span class="keyword">if</span> direct_mode
0216 
0217     <span class="comment">% --- direct mode: quickly collect NVPs from the arguments and produce a result ---</span>
0218     
0219     <span class="comment">% obtain flat NVP list</span>
0220     <span class="keyword">if</span> any(structs(1:2:end))
0221         vals = <a href="#_sub1" class="code" title="subfunction args = flatten_structs(args)">flatten_structs</a>(vals); <span class="keyword">end</span>
0222     
0223     <span class="keyword">if</span> nargout
0224         <span class="comment">% get names &amp; values</span>
0225         names = vals(1:2:end);
0226         values = vals(2:2:end);
0227         
0228         <span class="comment">% use only the last assignment for each name</span>
0229         [s,indices] = sort(names);
0230         indices(strcmp(s(1:end-1),s(2:end))) = [];
0231         
0232         <span class="comment">% build &amp; return a struct</span>
0233         res = cell2struct(values(indices),names(indices),2);        
0234     <span class="keyword">else</span>
0235         <span class="comment">% place the arguments in the caller's workspace</span>
0236         <span class="keyword">try</span>
0237             <span class="keyword">for</span> k=1:2:length(vals)
0238                 assignin(<span class="string">'caller'</span>,vals{k},vals{k+1}); <span class="keyword">end</span>
0239         <span class="keyword">catch</span> e
0240             <span class="keyword">if</span> strcmp(e.identifier,<span class="string">'MATLAB:err_static_workspace_violation'</span>)
0241                 error(<span class="string">'In a function with nested functions you need to capture the outputs of arg_define into a struct.'</span>); 
0242             <span class="keyword">else</span>
0243                 rethrow(e);
0244             <span class="keyword">end</span>
0245         <span class="keyword">end</span>
0246     <span class="keyword">end</span>
0247 
0248     <span class="keyword">try</span>
0249         <span class="comment">% also return the arguments in NVP form</span>
0250         assignin(<span class="string">'caller'</span>,<span class="string">'arg_nvps'</span>,vals);
0251     <span class="keyword">catch</span>
0252         <span class="comment">% this operation might be disallowed under some circumstances</span>
0253     <span class="keyword">end</span>
0254     
0255 <span class="keyword">else</span>    
0256     
0257     <span class="comment">% --- full parsing mode: determine the reporting type ---</span>
0258     
0259     <span class="comment">% usually, the reporting type is 'none', except if called (possibly indirectly) by</span>
0260     <span class="comment">% arg_report('type', ...): in this case, the reporting type is 'type' reporting is a special way to</span>
0261     <span class="comment">% call arg_define, which requests the argument specification, so that it can be displayed by GUIs,</span>
0262     <span class="comment">% etc.</span>
0263     <span class="comment">%</span>
0264     <span class="comment">% * 'none' normal execution: arg_define returns a Struct of Values to the Function or assigns the</span>
0265     <span class="comment">%          Struct's fields to the Function's workspace</span>
0266     <span class="comment">% * 'rich' arg_define yields a rich specifier list to arg_report(), basically an array of specifier</span>
0267     <span class="comment">%          structs (see arg_specifier for the field names)</span>
0268     <span class="comment">% * 'lean' arg_define yields a lean specifier list to arg_report(), basically an array of specifier</span>
0269     <span class="comment">%          structs but without alternatives for multi-option specifiers</span>
0270     <span class="comment">% * 'vals' arg_define yields a struct of values to arg_report(), wich can subsequently be used as</span>
0271     <span class="comment">%          the full specification of arguments to pass to the Function</span>
0272     
0273  
0274     <span class="keyword">try</span>
0275         throw; <span class="comment">%#ok&lt;LTARG&gt;                      % faster than error()</span>
0276     <span class="keyword">catch</span> context
0277         names = {context.stack(3:min(6,end)).name}; <span class="comment">% function names at the considered levels of indirection...</span>
0278         matches = find(strncmp(names,<span class="string">'arg_report_'</span>,11)); <span class="comment">% ... which start with 'arg_report_'</span>
0279         <span class="keyword">if</span> isempty(matches)
0280             reporting_type = <span class="string">'none'</span>;            <span class="comment">% no report requested (default case)</span>
0281         <span class="keyword">else</span>
0282             <span class="comment">% the reporting type is the suffix of the deepest arg_report_* function in the call stack</span>
0283             reporting_type = names{matches(end)}(11+1:end);
0284         <span class="keyword">end</span>
0285     <span class="keyword">end</span>
0286 
0287     <span class="comment">% --- deal with 'handle' and 'properties' reports ---</span>
0288     
0289     <span class="keyword">if</span> strcmp(reporting_type,<span class="string">'handle'</span>)        
0290         <span class="comment">% very special report type: 'handle'--&gt; this asks for function handles to nested / scoped</span>
0291         <span class="comment">% functions. unfortunately, these cannot be obtained using standard MATLAB functionality.</span>
0292         <span class="keyword">if</span> ~iscellstr(vals)
0293             error(<span class="string">'The arguments passed for handle report must denote function names.'</span>); <span class="keyword">end</span>
0294         unresolved = {};
0295         <span class="keyword">for</span> f=1:length(vals)
0296             <span class="comment">% resolve each function name in the caller scope</span>
0297             funcs{f} = evalin(<span class="string">'caller'</span>,[<span class="string">'@'</span> vals{f}]); 
0298             <span class="comment">% check if the function could be retrieved</span>
0299             tmp = functions(funcs{f});
0300             <span class="keyword">if</span> isempty(tmp.file)
0301                 unresolved{f} = vals{f}; <span class="keyword">end</span>      
0302         <span class="keyword">end</span>
0303         <span class="keyword">if</span> ~isempty(unresolved)
0304             <span class="comment">% search the remaining ones in the specification</span>
0305             <span class="keyword">for</span> f=find(~cellfun(<span class="string">'isempty'</span>,unresolved))
0306                 funcs{f} = hlp_microcache(<span class="string">'findfunction'</span>,@<a href="#_sub7" class="code" title="subfunction f = find_function_cached(spec,name)">find_function_cached</a>,spec,vals{f}); <span class="keyword">end</span>
0307         <span class="keyword">end</span>
0308         <span class="comment">% report it</span>
0309         <span class="keyword">if</span> length(funcs) == 1
0310             funcs = funcs{1}; <span class="keyword">end</span>
0311         <a href="arg_issuereport.html" class="code" title="function arg_issuereport(payload)">arg_issuereport</a>(funcs);
0312     <span class="keyword">elseif</span> strcmp(reporting_type,<span class="string">'properties'</span>)        
0313         <span class="comment">% 'properties' report, but no properties were declared</span>
0314         <a href="arg_issuereport.html" class="code" title="function arg_issuereport(payload)">arg_issuereport</a>(struct());
0315     <span class="keyword">end</span>
0316 
0317     <span class="comment">% --- one-time evaluation of the Specification list into a struct array ---</span>
0318 
0319     <span class="comment">% evaluate the specification or retrieve it from cache</span>
0320     [spec,all_names,joint_names,remap] = hlp_microcache(<span class="string">'spec'</span>,@<a href="#_sub2" class="code" title="subfunction [spec,all_names,joint_names,remap] = evaluate_spec(spec,reporting_type,require_namecheck)">evaluate_spec</a>,spec,reporting_type,nargout==0);
0321     
0322     <span class="comment">% --- transform vals to a pure list of name-value pairs (NVPs) ---</span>
0323 
0324     <span class="keyword">if</span> length(fmt) == 2
0325         <span class="keyword">if</span> fmt(1) ~= 0 || fmt(2) &lt;= 0
0326             <span class="comment">% This error is thrown when the first parameter to arg_define() was not a cell array (i.e., not varargin),</span>
0327             <span class="comment">% so that it is taken to denote the optional Format parameter.</span>
0328             <span class="comment">% Format is usually a numeric array that specifies the number of positional arguments that are</span>
0329             <span class="comment">% accepted by the function, and if numeric, it can only be either a number or a two-element array</span>
0330             <span class="comment">% that contains 0 and a non-zero number.</span>
0331             error(<span class="string">'For two-element formats, the first entry must be 0 and the second entry must be &gt; 0.'</span>); 
0332         <span class="keyword">end</span>
0333 
0334         <span class="comment">% there are two possible options: either 0 arguments are positional, or k arguments are</span>
0335         <span class="comment">% positional; assuming at first that 0 arguments are positional, splice substructs into one</span>
0336         <span class="comment">% uniform NVP list (this is because structs are allowed instead of individual NVPs)</span>
0337         <span class="keyword">if</span> any(cellfun(<span class="string">'isclass'</span>,vals(1:2:end),<span class="string">'struct'</span>))
0338             nvps = <a href="#_sub1" class="code" title="subfunction args = flatten_structs(args)">flatten_structs</a>(vals);
0339         <span class="keyword">else</span>
0340             nvps = vals;
0341         <span class="keyword">end</span>
0342 
0343         <span class="comment">% check if all the resulting names are in the set of allowed names (a disambiguation</span>
0344         <span class="comment">% condition in this case)</span>
0345         <span class="keyword">if</span> iscellstr(nvps(1:2:end))
0346             <span class="keyword">try</span>
0347                 disallowed_nvp = fast_setdiff(nvps(1:2:end),[joint_names {<span class="string">'arg_selection'</span>,<span class="string">'arg_direct'</span>}]);
0348             <span class="keyword">catch</span>
0349                 disallowed_nvp = setdiff(nvps(1:2:end),[joint_names {<span class="string">'arg_selection'</span>,<span class="string">'arg_direct'</span>}]);
0350             <span class="keyword">end</span>
0351         <span class="keyword">else</span>
0352             disallowed_nvp = <span class="string">'N/A'</span>;
0353         <span class="keyword">end</span>
0354 
0355         <span class="keyword">if</span> isempty(disallowed_nvp)
0356             <span class="comment">% the assumption was correct: 0 arguments are positional</span>
0357             fmt = 0;
0358         <span class="keyword">else</span>
0359             <span class="comment">% the assumption was violated: most likely k arguments are positional</span>
0360             <span class="comment">% but check if at least one of the names in the first k arguments would have matched</span>
0361             <span class="comment">% and warn if so</span>
0362             <span class="keyword">if</span> iscellstr(nvps(1:2:end))
0363                 matching_nvp = intersect(nvps(1:2:min(<span class="keyword">end</span>,max(fmt))),[joint_names {<span class="string">'arg_selection'</span>,<span class="string">'arg_direct'</span>}]);
0364                 <span class="keyword">if</span> ~isempty(matching_nvp)
0365                     <span class="comment">% if you get this warning you passed in a sequence of parameters to a function that uses</span>
0366                     <span class="comment">% arg_define and permits both 1) a number of positional arguments followed by name-value pairs</span>
0367                     <span class="comment">% or 2) alternatively all arguments passed in as name-value pairs. If your sequence is</span>
0368                     <span class="comment">% interpreted as all name-value pairs (case 2), a fraction of them are recognized as matching</span>
0369                     <span class="comment">% arguments (indicating that they are indeed NVPs), while another fraction of them are</span>
0370                     <span class="comment">% not recognized (indicating that the sequence is in fact consisting of some positional arguments).</span>
0371                     <span class="comment">% Therefore either the matching names are actually values that you passed in (and spuriously match),</span>
0372                     <span class="comment">% or you have a typo in one of your intended argument names, or perhaps the argument has been removed</span>
0373                     <span class="comment">% from the function.</span>
0374                     caller = <a href="#_sub4  5" class="code" title="subfunction_caller = hlp_getcaller(4);function_caller = hlp_getcaller(14); end">hlp_getcaller</a>;
0375                     warn_once([caller <span class="string">':arg_define:possible_conflict'</span>],<span class="string">'arg_define() in %s: Possible parameter conflict -- both unrecognized names %s and matching names %s passed in. Assuming that the function is called with some positional arguments. This warning will not be repeated for this MATLAB session.'</span>,caller,hlp_tostring(disallowed_nvp),hlp_tostring(matching_nvp)); 
0376                 <span class="keyword">end</span>
0377             <span class="keyword">end</span>
0378             strict_names = true;
0379             fmt = fmt(2);
0380         <span class="keyword">end</span>
0381     <span class="keyword">elseif</span> fmt == 0
0382         <span class="comment">% 0 arguments are positional</span>
0383         nvps = <a href="#_sub1" class="code" title="subfunction args = flatten_structs(args)">flatten_structs</a>(vals);
0384     <span class="keyword">elseif</span> fmt &gt; 0
0385         <span class="comment">% k arguments are positional, the rest are NVPs (no need to enforce strict naming here)</span>
0386         strict_names = false;
0387     <span class="keyword">else</span>
0388         <span class="comment">% This error refers to the optional Format argument.</span>
0389         error(<span class="string">'Negative or NaN formats are not allowed.'</span>);
0390     <span class="keyword">end</span>
0391 
0392     <span class="comment">% (from now on fmt holds the determined # of positional arguments)</span>
0393     
0394     <span class="keyword">if</span> fmt &gt; 0
0395         <span class="comment">% the first k arguments are positional</span>
0396 
0397         <span class="comment">% Find out if we are being called by another arg_define; in this case, this definition</span>
0398         <span class="comment">% appears inside an arg_sub/arg_*, and the values passed to the arg_define are part of the</span>
0399         <span class="comment">% defaults declaration of one of these. If these defaults are specified positionally, the</span>
0400         <span class="comment">% first k arg_norep() arguments in Specification are implicitly skipped.</span>
0401         <span class="keyword">if</span> ~strcmp(reporting_type,<span class="string">'none'</span>) &amp;&amp; any(strcmp(<span class="string">'arg_define'</span>,{context.stack(2:end).name}));
0402             <span class="comment">% we implicitly skip the leading non-reportable arguments in the case of positional</span>
0403             <span class="comment">% assignment (assuming that these are supplied by the outer function), by shifting the</span>
0404             <span class="comment">% name/value assignment by the appropriate number of places</span>
0405             shift_positionals = min(fmt,find([spec.reportable],1)-1);
0406         <span class="keyword">else</span>
0407             shift_positionals = 0;
0408         <span class="keyword">end</span>
0409 
0410         <span class="comment">% get the effective number of positional arguments</span>
0411         fmt = min(fmt,length(vals)+shift_positionals);
0412 
0413         <span class="comment">% the NVPs begin only after the k'th argument (defined by the Format)</span>
0414         nvps = vals(fmt+1-shift_positionals:end);
0415 
0416         <span class="comment">% splice in any structs</span>
0417         <span class="keyword">if</span> any(cellfun(<span class="string">'isclass'</span>,nvps(1:2:end),<span class="string">'struct'</span>))
0418             nvps = <a href="#_sub1" class="code" title="subfunction args = flatten_structs(args)">flatten_structs</a>(nvps); <span class="keyword">end</span>
0419 
0420         <span class="comment">% do minimal error checking...</span>
0421         <span class="keyword">if</span> ~iscellstr(nvps(1:2:end))
0422             <span class="comment">% If you are getting this error, the order of names and values passed as name-value pairs</span>
0423             <span class="comment">% to the function in question was likely mixed up. The error mentions structs because it</span>
0424             <span class="comment">% is also allowed to pass in a struct in place of any 'name',value pair.</span>
0425             error(<span class="string">'Some of the specified arguments that should be names or structs, are not.'</span>); 
0426         <span class="keyword">end</span>
0427 
0428         <span class="keyword">if</span> strict_names
0429             <span class="comment">% enforce strict names</span>
0430             <span class="keyword">try</span>
0431                 disallowed_pos = fast_setdiff(nvps(1:2:end),[joint_names {<span class="string">'arg_selection'</span>,<span class="string">'arg_direct'</span>}]);
0432             <span class="keyword">catch</span>
0433                 disallowed_pos = setdiff(nvps(1:2:end),[joint_names {<span class="string">'arg_selection'</span>,<span class="string">'arg_direct'</span>}]);
0434             <span class="keyword">end</span>
0435             <span class="keyword">if</span> ~isempty(disallowed_pos)
0436                 <span class="comment">% If you are getting this error, it is most likely due to a mis-typed argument name</span>
0437                 <span class="comment">% in the list of name-value pairs passed to the function in question.</span>
0438                 <span class="comment">%</span>
0439                 <span class="comment">% Because some functions may support also positional arguments, it is also possible</span>
0440                 <span class="comment">% that something that was supposed to be the value for one of the positional</span>
0441                 <span class="comment">% arguments was interpreted as part of the name-value pairs lit that may follow the</span>
0442                 <span class="comment">% positional arguments of the function. This error is likely because the wrong number</span>
0443                 <span class="comment">% of positional arguments was passed (a safer alternative is to instead pass everything</span>
0444                 <span class="comment">% by name).</span>
0445                 error([<span class="string">'Some of the specified arguments do not appear in the argument specification; '</span> <a href="#_sub8" class="code" title="subfunction x = format_cellstr(x)">format_cellstr</a>(disallowed_pos) <span class="string">'.'</span>]); 
0446             <span class="keyword">end</span>
0447         <span class="keyword">end</span>
0448 
0449         <span class="keyword">try</span>
0450             <span class="comment">% remap the positionals (everything up to the k'th argument) into an NVP list, using the</span>
0451             <span class="comment">% code names</span>
0452             poss = [cellfun(@(x)x{1},all_names(shift_positionals+1:fmt),<span class="string">'UniformOutput'</span>,false); vals(1:fmt-shift_positionals)];
0453         <span class="keyword">catch</span>
0454             <span class="keyword">if</span> strict_names
0455                 <span class="keyword">if</span> iscell(disallowed_nvp)
0456                     <span class="comment">% maybe the user intended to pass 0 positionals, but used some disallowed names</span>
0457                     error([<span class="string">'Apparently, some of the used argument names are not known to function '</span> <a href="#_sub4  5" class="code" title="subfunction_caller = hlp_getcaller(4);function_caller = hlp_getcaller(14); end">hlp_getcaller</a> <span class="string">': '</span> <a href="#_sub8" class="code" title="subfunction x = format_cellstr(x)">format_cellstr</a>(disallowed_nvp) <span class="string">'.'</span>]);
0458                 <span class="keyword">else</span>
0459                     <span class="comment">% maybe the user intended to pass 0 positionals, but used some disallowed names</span>
0460                     error([<span class="string">'Possibly the argument order was confused when calling '</span> <a href="#_sub4  5" class="code" title="subfunction_caller = hlp_getcaller(4);function_caller = hlp_getcaller(14); end">hlp_getcaller</a> <span class="string">': '</span> hlp_tostring(vals,20) <span class="string">'.'</span>]);
0461                 <span class="keyword">end</span>                    
0462             <span class="keyword">else</span>
0463                 error([<span class="string">'The first '</span> fmt <span class="string">' arguments must be passed by position, and the remaining ones must be passed by name (either in name-value pairs or structs).'</span>]);
0464             <span class="keyword">end</span>
0465         <span class="keyword">end</span>
0466         <span class="comment">% ... and concatenate them with the remaining NVPs into one big NVP list</span>
0467         nvps = [poss(:)' nvps];
0468     <span class="keyword">end</span>
0469 
0470 
0471     <span class="comment">% --- assign values to names using the assigner functions of the spec ---</span>
0472 
0473     <span class="keyword">for</span> k=1:2:length(nvps)
0474         <span class="keyword">if</span> isfield(remap,nvps{k})
0475             idx = remap.(nvps{k});
0476             newvalue = nvps{k+1};
0477             <span class="keyword">if</span> spec(idx).deprecated &amp;&amp; ~isequal_weak(spec(idx).value,newvalue)
0478                 <span class="keyword">if</span> ~isempty(spec(idx).help)
0479                     disp_once([<span class="string">'Using deprecated argument &quot;'</span> nvps{k} <span class="string">'&quot; in function '</span> <a href="#_sub4  5" class="code" title="subfunction_caller = hlp_getcaller(4);function_caller = hlp_getcaller(14); end">hlp_getcaller</a> <span class="string">' (help: '</span> [spec(idx).help{:}] <span class="string">').'</span>]);
0480                 <span class="keyword">else</span>
0481                     disp_once([<span class="string">'Using deprecated argument &quot;'</span> nvps{k} <span class="string">'&quot; in function '</span> <a href="#_sub4  5" class="code" title="subfunction_caller = hlp_getcaller(4);function_caller = hlp_getcaller(14); end">hlp_getcaller</a> <span class="string">'.'</span>]); 
0482                 <span class="keyword">end</span>
0483             <span class="keyword">end</span>
0484             spec(idx) = spec(idx).assigner(spec(idx),newvalue);
0485         <span class="keyword">else</span>
0486             <span class="comment">% append it to the spec (note: this might need some optimization... it would be better</span>
0487             <span class="comment">% if the spec automatically contained the arg_selection field)</span>
0488             tmp = <a href="arg_nogui.html" class="code" title="function res = arg_nogui(varargin)">arg_nogui</a>(nvps{k},nvps{k+1});
0489             spec(end+1) = tmp{1}([],tmp{2}{:});
0490         <span class="keyword">end</span>
0491     <span class="keyword">end</span>
0492     
0493     
0494     <span class="comment">% --- if requested, yield a 'vals', 'lean' or 'rich' report  ---</span>
0495 
0496     <span class="keyword">if</span> ~strcmp(reporting_type,<span class="string">'none'</span>)        
0497         <span class="comment">% but deliver only the reportable arguments, and only if the values are not unassigned</span>
0498         tmp = spec([spec.reportable] &amp; ~strcmp(unassigned,{spec.value}));
0499         <span class="keyword">if</span> strcmp(reporting_type,<span class="string">'vals'</span>)
0500             tmp = <a href="arg_tovals.html" class="code" title="function res = arg_tovals(spec,direct)">arg_tovals</a>(tmp); <span class="keyword">end</span>
0501         <a href="arg_issuereport.html" class="code" title="function arg_issuereport(payload)">arg_issuereport</a>(tmp);
0502     <span class="keyword">end</span>
0503 
0504     
0505     <span class="comment">% --- otherwise post-process the outputs and create a result struct to pass to the Function ---</span>
0506 
0507     <span class="comment">% generate errors for mandatory arguments that were not assigned</span>
0508     missing_entries = strcmp(mandatory,{spec.value});
0509     <span class="keyword">if</span> any(missing_entries)
0510         missing_names = cellfun(@(x)x{1},{spec(missing_entries).names},<span class="string">'UniformOutput'</span>,false);
0511         error([<span class="string">'The arguments '</span> <a href="#_sub8" class="code" title="subfunction x = format_cellstr(x)">format_cellstr</a>(missing_names) <span class="string">' were unspecified but are mandatory.'</span>]);
0512     <span class="keyword">end</span>
0513 
0514     <span class="comment">% strip non-returned arguments, and convert it all to a struct of values</span>
0515     res = <a href="arg_tovals.html" class="code" title="function res = arg_tovals(spec,direct)">arg_tovals</a>(spec);
0516 
0517     <span class="comment">% also emit a final NVPs list</span>
0518     tmp = [fieldnames(res) struct2cell(res)]';
0519     <span class="keyword">try</span>
0520         assignin(<span class="string">'caller'</span>,<span class="string">'arg_nvps'</span>,tmp(:)');
0521     <span class="keyword">catch</span>
0522         <span class="comment">% this operation might be disallowed under some circumstances</span>
0523     <span class="keyword">end</span>
0524     
0525     <span class="comment">% if requested, place the arguments in the caller's workspace</span>
0526     <span class="keyword">if</span> nargout==0
0527         <span class="keyword">try</span>
0528             <span class="keyword">for</span> fn=fieldnames(res)'
0529                 assignin(<span class="string">'caller'</span>,fn{1},res.(fn{1})); <span class="keyword">end</span>
0530         <span class="keyword">catch</span> e
0531             <span class="keyword">if</span> strcmp(e.identifier,<span class="string">'MATLAB:err_static_workspace_violation'</span>)
0532                 error(<span class="string">'In a function with nested functions you need to capture the outputs of arg_define into a struct.'</span>); 
0533             <span class="keyword">else</span>
0534                 rethrow(e);
0535             <span class="keyword">end</span>
0536         <span class="keyword">end</span>
0537     <span class="keyword">end</span>
0538 <span class="keyword">end</span>
0539 
0540 
0541 
0542 <span class="comment">% substitute any structs in place of a name-value pair into the name-value list</span>
0543 <a name="_sub1" href="#_subfunctions" class="code">function args = flatten_structs(args)</a>
0544 k = 1;
0545 <span class="keyword">while</span> k &lt;= length(args)
0546     <span class="keyword">if</span> isstruct(args{k})
0547         tmp = [fieldnames(args{k}) struct2cell(args{k})]';
0548         args = [args(1:k-1) tmp(:)' args(k+1:end)];
0549         k = k+numel(tmp);
0550     <span class="keyword">else</span>
0551         k = k+2;
0552     <span class="keyword">end</span>
0553 <span class="keyword">end</span>
0554 
0555 
0556 
0557 <span class="comment">% evaluate a specification into a struct array</span>
0558 <a name="_sub2" href="#_subfunctions" class="code">function [spec,all_names,joint_names,remap] = evaluate_spec(spec,reporting_type,require_namecheck)</a>
0559 <span class="keyword">if</span> strcmp(reporting_type,<span class="string">'rich'</span>)
0560     subreport_type = <span class="string">'rich'</span>;
0561 <span class="keyword">else</span>
0562     subreport_type = <span class="string">'lean'</span>;
0563 <span class="keyword">end</span>
0564 
0565 <span class="comment">% evaluate the functions to get (possibly arrays of) specifier structs</span>
0566 <span class="keyword">for</span> k=1:length(spec)
0567     spec{k} = spec{k}{1}(subreport_type,spec{k}{2}{:}); <span class="keyword">end</span>
0568 
0569 <span class="comment">% concatenate the structs to one big struct array</span>
0570 spec = [spec{:}];
0571 
0572 <span class="comment">% make sure that spec has the correct fields, even if empty</span>
0573 <span class="keyword">if</span> isempty(spec)
0574     spec = <a href="arg_specifier.html" class="code" title="function spec = arg_specifier(varargin)">arg_specifier</a>; 
0575     spec = spec([]);
0576 <span class="keyword">end</span>
0577 
0578 <span class="comment">% obtain the argument names and the joined names</span>
0579 all_names = {spec.names};
0580 joint_names = [all_names{:}];
0581 
0582 <span class="comment">% create a name/index remapping table</span>
0583 remap = struct();
0584 <span class="keyword">for</span> n=1:length(all_names)
0585     <span class="keyword">for</span> k=1:length(all_names{n})
0586         remap.(all_names{n}{k}) = n; <span class="keyword">end</span>
0587 <span class="keyword">end</span>
0588 
0589 <span class="comment">% check for duplicate argument names in the Specification</span>
0590 sorted_names = sort(joint_names);
0591 duplicates = joint_names(strcmp(sorted_names(1:end-1),sorted_names(2:end)));  
0592 <span class="keyword">if</span> ~isempty(duplicates)
0593     error([<span class="string">'The names '</span> <a href="#_sub8" class="code" title="subfunction x = format_cellstr(x)">format_cellstr</a>(duplicates) <span class="string">' refer to multiple arguments.'</span>]); <span class="keyword">end</span>
0594 
0595 <span class="comment">% if required, check for name clashes with functions on the path</span>
0596 <span class="comment">% (this is due to a glitch in MATLAB's handling of variables that were assigned to a function's scope</span>
0597 <span class="comment">% from the outside, which are prone to clashes with functions on the path...)</span>
0598 <span class="keyword">if</span> require_namecheck &amp;&amp; strcmp(reporting_type,<span class="string">'none'</span>)
0599     <span class="keyword">try</span>
0600         <a href="#_sub3" class="code" title="subfunction check_names(code_names)">check_names</a>(cellfun(@(x)x{1},all_names,<span class="string">'UniformOutput'</span>,false));
0601     <span class="keyword">catch</span> e
0602         disp_once(<span class="string">'The function check_names failed; reason: %s'</span>,e.message);
0603     <span class="keyword">end</span>
0604 <span class="keyword">end</span>
0605 
0606 
0607 
0608 <span class="comment">% check for name clashes (once)</span>
0609 <a name="_sub3" href="#_subfunctions" class="code">function check_names(code_names)</a>
0610 <span class="keyword">persistent</span> name_table;
0611 <span class="keyword">if</span> ~isstruct(name_table)
0612     name_table = struct(); <span class="keyword">end</span>
0613 <span class="keyword">for</span> name_cell = fast_setdiff(code_names,fieldnames(name_table))
0614     current_name = name_cell{1};
0615     existing_func = which(current_name);
0616     <span class="keyword">if</span> ~isempty(existing_func)
0617         <span class="keyword">if</span> ~exist(<span class="string">'function_caller'</span>,<span class="string">'var'</span>)
0618             <a name="_sub4" href="#_subfunctions" class="code">function_caller = hlp_getcaller(4); </a>
0619             <span class="keyword">if</span> function_caller(1) == <span class="string">'@'</span>
0620                 <a name="_sub5" href="#_subfunctions" class="code">function_caller = hlp_getcaller(14); end</a>
0621         <span class="keyword">end</span>
0622         <span class="keyword">if</span> isempty(strfind(existing_func,<span class="string">'Java method'</span>))
0623             [path_part,file_part,ext_part] = fileparts(existing_func);
0624             <span class="keyword">if</span> ~any(strncmp(<span class="string">'@'</span>,hlp_split(path_part,filesep),1))
0625                 <span class="comment">% If this happens, it means that there is a function in one of the directories in</span>
0626                 <span class="comment">% MATLAB's path which has the same name as an argument of the specification. If this</span>
0627                 <span class="comment">% argument variable is copied into the function's workspace by arg_define, most MATLAB</span>
0628                 <span class="comment">% versions will (incorrectly) try to call that function instead of accessing the</span>
0629                 <span class="comment">% variable. I hope that they handle this issue at some point. One workaround is to use</span>
0630                 <span class="comment">% a longer argument name (that is less likely to clash) and, if it should still be</span>
0631                 <span class="comment">% usable for parameter passing, to retain the old name as a secondary or ternary</span>
0632                 <span class="comment">% argument name (using a cell array of names in arg()). The only really good</span>
0633                 <span class="comment">% solution at this point is to generally assign the output of arg_define to a</span>
0634                 <span class="comment">% struct.</span>
0635                 disp([function_caller <span class="string">': The argument name &quot;'</span> current_name <span class="string">'&quot; clashes with the function &quot;'</span> [file_part ext_part] <span class="string">'&quot; in directory &quot;'</span> path_part <span class="string">'&quot;; it is strongly recommended that you either rename the function or remove it from the path.'</span>]); 
0636             <span class="keyword">end</span>
0637         <span class="keyword">else</span>
0638             <span class="comment">% these Java methods are probably spurious &quot;false positives&quot; of the which() function</span>
0639             disp([function_caller <span class="string">': There is a Java method named &quot;'</span> current_name <span class="string">'&quot; on your path; if you experience any name clash with it, please report this issue.'</span>]);
0640         <span class="keyword">end</span>
0641     <span class="keyword">end</span>
0642     name_table.(current_name) = existing_func;
0643 <span class="keyword">end</span>
0644 
0645 
0646 
0647 <span class="comment">% recursively find a function handle by name in a specification</span>
0648 <span class="comment">% the first occurrence of a handle to a function with the given name is returned</span>
0649 <a name="_sub6" href="#_subfunctions" class="code">function r = find_function(spec,name)</a>
0650 r = [];
0651 <span class="keyword">for</span> k=1:length(spec)
0652     <span class="keyword">if</span> isa(spec(k).value,<span class="string">'function_handle'</span>) &amp;&amp; strcmp(char(spec(k).value),name)
0653         r = spec(k).value; 
0654         <span class="keyword">return</span>;
0655     <span class="keyword">elseif</span> ~isempty(spec(k).alternatives)
0656         <span class="keyword">for</span> n = 1:length(spec(k).alternatives)
0657             r = <a href="#_sub6" class="code" title="subfunction r = find_function(spec,name)">find_function</a>(spec(k).alternatives{n},name);
0658             <span class="keyword">if</span> ~isempty(r)
0659                 <span class="keyword">return</span>; <span class="keyword">end</span>
0660         <span class="keyword">end</span>
0661     <span class="keyword">elseif</span> ~isempty(spec(k).children)
0662         r = <a href="#_sub6" class="code" title="subfunction r = find_function(spec,name)">find_function</a>(spec(k).children,name);
0663         <span class="keyword">if</span> ~isempty(r)
0664             <span class="keyword">return</span>; <span class="keyword">end</span>
0665     <span class="keyword">end</span>
0666 <span class="keyword">end</span>
0667 
0668 
0669 
0670 <span class="comment">% find a function handle by name in a specification</span>
0671 <a name="_sub7" href="#_subfunctions" class="code">function f = find_function_cached(spec,name)</a>
0672 <span class="comment">% evaluate the functions to get (possibly arrays of) specifier structs</span>
0673 <span class="keyword">for</span> k=1:length(spec)
0674     spec{k} = spec{k}{1}(<span class="string">'rich'</span>,spec{k}{2}{:}); <span class="keyword">end</span>
0675 <span class="comment">% concatenate the structs to one big struct array</span>
0676 spec = [spec{:}];
0677 <span class="comment">% now search the function in it</span>
0678 f = <a href="#_sub6" class="code" title="subfunction r = find_function(spec,name)">find_function</a>(spec,name);
0679 
0680 
0681 
0682 <span class="comment">% format a non-empty cell-string array into a string</span>
0683 <a name="_sub8" href="#_subfunctions" class="code">function x = format_cellstr(x)</a>
0684 x = [<span class="string">'{'</span> sprintf(<span class="string">'%s, '</span>,x{1:end-1}) x{end} <span class="string">'}'</span>];</pre></div>
<hr><address>Generated on Tue 20-Aug-2013 03:44:10 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>