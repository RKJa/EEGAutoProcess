<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of ParadigmSIFT</title>
  <meta name="keywords" content="ParadigmSIFT">
  <meta name="description" content="">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">code</a> &gt; <a href="index.html">paradigms</a> &gt; ParadigmSIFT.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for code/paradigms&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>ParadigmSIFT
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong></strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="ParadigmDataflowSimplified.html" class="code" title="">ParadigmDataflowSimplified</a>	</li><li><a href="ParadigmSIFT.html" class="code" title="">ParadigmSIFT</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="ParadigmSIFT.html" class="code" title="">ParadigmSIFT</a>	</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function defaults = preprocessing_defaults(self)</a></li><li><a href="#_sub2" class="code">function defaults = machine_learning_defaults(self)</a></li><li><a href="#_sub3" class="code">function model = feature_adapt(self,varargin)</a></li><li><a href="#_sub4" class="code">function [features,shape] = feature_extract(self,signal,featuremodel)</a></li><li><a href="#_sub5" class="code">function visualize_model(self,parent,featuremodel,predictivemodel,varargin)</a></li><li><a href="#_sub6" class="code">function layout = dialog_layout_defaults(self)</a></li><li><a href="#_sub7" class="code">function tf = needs_voting(self)</a></li><li><a href="#_sub8" class="code">function sig = make_continuous(self,sig)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 classdef <a href="ParadigmSIFT.html" class="code" title="">ParadigmSIFT</a> &lt; <a href="ParadigmDataflowSimplified.html" class="code" title="">ParadigmDataflowSimplified</a>
0002     <span class="comment">% Source Information Toolbox adapter paradigm.</span>
0003     <span class="comment">%</span>
0004     <span class="comment">% This paradigm exposes SIFT-derived connectivity features within BCILAB.</span>
0005     <span class="comment">%</span>
0006     <span class="comment">% Name:</span>
0007     <span class="comment">%   Source Information Flow Toolbox Adapter</span>
0008     <span class="comment">%</span>
0009     
0010     
0011     methods
0012       
0013         <a name="_sub0" href="#_subfunctions" class="code">function defaults = preprocessing_defaults(self)</a>
0014             <span class="comment">% define the default pre-processing parameters of this paradigm</span>
0015             defaults = { <span class="keyword">...</span>
0016                 <span class="string">'Resampling'</span>,128, <span class="keyword">...</span>
0017                 <span class="string">'DataCleaning'</span>,{<span class="keyword">...</span><span class="comment">                    </span>
0018                     <span class="string">'DataSetting'</span>,{<span class="string">'drycap'</span> <span class="keyword">...</span>
0019                         <span class="string">'DriftCutoff'</span>,[0.1 1], <span class="keyword">...</span>
0020                         <span class="string">'BadSubspaceRemoval'</span>,{ <span class="keyword">...</span>
0021                             <span class="string">'StandardDevCutoff'</span>,4, <span class="keyword">...</span>
0022                             <span class="string">'ProcessingDelay'</span>,0.125}, <span class="keyword">...</span>
0023                      }, <span class="keyword">...</span>
0024                     <span class="string">'HaveChannelDropouts'</span>,false, <span class="keyword">...</span>
0025                     <span class="string">'RetainPhases'</span>,false}, <span class="keyword">...</span>
0026                 <span class="string">'Rereferencing'</span>,<span class="string">'on'</span>, <span class="keyword">...</span>
0027                 <span class="string">'SourceLocalization'</span>, {<span class="keyword">...</span>
0028                     <span class="string">'InverseMethod'</span>, { <span class="keyword">...</span>
0029                         <span class="string">'LORETA'</span>, <span class="keyword">...</span>
0030                         <span class="string">'LoretaOptions'</span>,{<span class="keyword">...</span>
0031                             <span class="string">'MaxIterations'</span>,50,<span class="keyword">...</span>
0032                             <span class="string">'BlockSize'</span>,32,<span class="keyword">...</span>
0033                             <span class="string">'SkipFactor'</span>,0}}, <span class="keyword">...</span><span class="comment">.</span>
0034                     <span class="string">'SourceAtlasROI'</span>,{<span class="string">'Precentral_L'</span> <span class="string">'Precentral_R'</span> <span class="string">'Frontal_Sup_L'</span> <span class="string">'Frontal_Sup_R'</span> <span class="string">'Frontal_Sup_Orb_L'</span> <span class="string">'Frontal_Sup_Orb_R'</span> <span class="string">'Frontal_Mid_L'</span> <span class="string">'Frontal_Mid_R'</span> <span class="string">'Frontal_Mid_Orb_L'</span> <span class="string">'Frontal_Mid_Orb_R'</span> <span class="string">'Frontal_Inf_Oper_L'</span> <span class="string">'Frontal_Inf_Oper_R'</span> <span class="string">'Frontal_Inf_Tri_L'</span> <span class="string">'Frontal_Inf_Tri_R'</span> <span class="string">'Frontal_Inf_Orb_L'</span> <span class="string">'Frontal_Inf_Orb_R'</span> <span class="string">'Rolandic_Oper_L'</span> <span class="string">'Rolandic_Oper_R'</span> <span class="string">'Supp_Motor_Area_L'</span> <span class="string">'Supp_Motor_Area_R'</span> <span class="string">'Olfactory_L'</span> <span class="string">'Olfactory_R'</span> <span class="string">'Frontal_Sup_Medial_L'</span> <span class="string">'Frontal_Sup_Medial_R'</span> <span class="string">'Frontal_Mid_Orb_L'</span> <span class="string">'Frontal_Mid_Orb_R'</span> <span class="string">'Rectus_L'</span> <span class="string">'Rectus_R'</span> <span class="string">'Insula_L'</span> <span class="string">'Insula_R'</span> <span class="string">'Cingulum_Ant_L'</span> <span class="string">'Cingulum_Ant_R'</span> <span class="string">'Cingulum_Mid_L'</span> <span class="string">'Cingulum_Mid_R'</span> <span class="string">'Cingulum_Post_L'</span> <span class="string">'Cingulum_Post_R'</span> <span class="string">'Hippocampus_L'</span> <span class="string">'Hippocampus_R'</span> <span class="string">'ParaHippocampal_L'</span> <span class="string">'ParaHippocampal_R'</span> <span class="string">'Amygdala_L'</span> <span class="string">'Amygdala_R'</span> <span class="string">'Calcarine_L'</span> <span class="string">'Calcarine_R'</span> <span class="string">'Cuneus_L'</span> <span class="string">'Cuneus_R'</span> <span class="string">'Lingual_L'</span> <span class="string">'Lingual_R'</span> <span class="string">'Occipital_Sup_L'</span> <span class="string">'Occipital_Sup_R'</span> <span class="string">'Occipital_Mid_L'</span> <span class="string">'Occipital_Mid_R'</span> <span class="string">'Occipital_Inf_L'</span> <span class="string">'Occipital_Inf_R'</span> <span class="string">'Fusiform_L'</span> <span class="string">'Fusiform_R'</span> <span class="string">'Postcentral_L'</span> <span class="string">'Postcentral_R'</span> <span class="string">'Parietal_Sup_L'</span> <span class="string">'Parietal_Sup_R'</span> <span class="string">'Parietal_Inf_L'</span> <span class="string">'Parietal_Inf_R'</span> <span class="string">'SupraMarginal_L'</span> <span class="string">'SupraMarginal_R'</span> <span class="string">'Angular_L'</span> <span class="string">'Angular_R'</span> <span class="string">'Precuneus_L'</span> <span class="string">'Precuneus_R'</span> <span class="string">'Paracentral_Lobule_L'</span> <span class="string">'Paracentral_Lobule_R'</span> <span class="string">'Heschl_L'</span> <span class="string">'Heschl_R'</span> <span class="string">'Temporal_Sup_L'</span> <span class="string">'Temporal_Sup_R'</span> <span class="string">'Temporal_Pole_Sup_L'</span> <span class="string">'Temporal_Pole_Sup_R'</span> <span class="string">'Temporal_Mid_L'</span> <span class="string">'Temporal_Mid_R'</span> <span class="string">'Temporal_Pole_Mid_L'</span> <span class="string">'Temporal_Pole_Mid_R'</span> <span class="string">'Temporal_Inf_L'</span> <span class="string">'Temporal_Inf_R'</span>}, <span class="keyword">...</span>
0035                     <span class="string">'AtlasROI'</span>, {<span class="string">'Precentral_L'</span> <span class="string">'Precentral_R'</span> <span class="string">'Frontal_Sup_L'</span> <span class="string">'Frontal_Sup_R'</span> <span class="string">'Frontal_Mid_L'</span> <span class="string">'Frontal_Mid_R'</span> <span class="string">'Supp_Motor_Area_L'</span> <span class="string">'Supp_Motor_Area_R'</span> <span class="string">'Cingulum_Ant_L'</span> <span class="string">'Cingulum_Ant_R'</span> <span class="string">'Cingulum_Mid_L'</span> <span class="string">'Cingulum_Mid_R'</span> <span class="string">'Cingulum_Post_L'</span> <span class="string">'Cingulum_Post_R'</span> <span class="string">'Occipital_Mid_L'</span> <span class="string">'Occipital_Mid_R'</span>}, <span class="keyword">...</span><span class="comment"> </span>
0036                     <span class="string">'Verbosity'</span>,true}, <span class="keyword">...</span>
0037                 <span class="string">'FIRFilter'</span>,{ <span class="keyword">...</span>
0038                     <span class="string">'Frequencies'</span>,[45 50], <span class="keyword">...</span>
0039                     <span class="string">'Type'</span>,<span class="string">'minimum-phase'</span>, <span class="keyword">...</span>
0040                     <span class="string">'Mode'</span>,<span class="string">'lowpass'</span>},<span class="keyword">...</span>
0041                 <span class="string">'EpochExtraction'</span>,[-0.2 1]};
0042         <span class="keyword">end</span>
0043         
0044         <a name="_sub1" href="#_subfunctions" class="code">function defaults = machine_learning_defaults(self)</a>
0045             defaults = {<span class="string">'logreg'</span>, <span class="keyword">...</span>
0046                         <span class="string">'Variant'</span>,{<span class="string">'lars'</span>, <span class="keyword">...</span>
0047                             <span class="string">'ElasticMixing'</span>,0.5, <span class="keyword">...</span>
0048                             <span class="string">'MinLambda'</span>,0.0001,<span class="keyword">...</span>
0049                             <span class="string">'CustomLoss'</span>,<span class="string">'auc'</span>}};
0050         <span class="keyword">end</span>
0051         
0052         <a name="_sub2" href="#_subfunctions" class="code">function model = feature_adapt(self,varargin)</a>
0053             <span class="comment">% configure and adapt parameters for SIFT's online pipeline</span>
0054             g = arg_define(varargin, <span class="keyword">...</span>
0055                     arg_norep(<span class="string">'signal'</span>), <span class="keyword">...</span>
0056                     arg_sub({<span class="string">'connPipeline'</span>,<span class="string">'ConnectivityPipeline'</span>},{<span class="string">'EEG'</span>,struct(<span class="string">'srcpot'</span>,1,<span class="string">'icaweights'</span>,1), <span class="keyword">...</span>
0057                         <span class="string">'Preprocessing'</span>,{ <span class="keyword">...</span>
0058                             <span class="string">'VerbosityLevel'</span>,0,<span class="keyword">...</span>
0059                             <span class="string">'SignalType'</span>,<span class="string">'Sources'</span>, <span class="keyword">...</span>
0060                             <span class="string">'Detrend'</span>,{<span class="string">'DetrendingMethod'</span>,{<span class="string">'linear'</span>}},<span class="keyword">...</span>
0061                             <span class="string">'NormalizeData'</span>,{}}, <span class="keyword">...</span>
0062                         <span class="string">'Modeling'</span>,{ <span class="keyword">...</span>
0063                             <span class="string">'Segmentation VAR'</span>, <span class="keyword">...</span>
0064                                 <span class="string">'Algorithm'</span>,{<span class="string">'Group Lasso (ADMM)'</span>, <span class="keyword">...</span>
0065                                     <span class="string">'WarmStart'</span>,<span class="string">'on'</span>, <span class="keyword">...</span>
0066                                     <span class="string">'NormCols'</span>,<span class="string">'norm'</span>, <span class="keyword">...</span>
0067                                     <span class="string">'ADMM_Options'</span>, {<span class="keyword">...</span>
0068                                         <span class="string">'ReguParamLambda'</span>,search(2.^[-15:1.5:-3]), <span class="keyword">...</span>
0069                                         <span class="string">'Verbosity'</span>,false, <span class="keyword">...</span>
0070                                         <span class="string">'MaxIterations'</span>,150, <span class="keyword">...</span>
0071                                         <span class="string">'LambdaUpdate'</span>,false <span class="keyword">...</span>
0072                                         }}, <span class="keyword">...</span>
0073                             <span class="string">'Detrend'</span>,<span class="string">'off'</span>, <span class="keyword">...</span>
0074                             <span class="string">'VerbosityLevel'</span>,0}, <span class="keyword">...</span>
0075                         <span class="string">'AutoSelectModelOrder'</span>,[], <span class="keyword">...</span>
0076                         <span class="string">'Connectivity'</span>, { <span class="keyword">...</span>
0077                             <span class="string">'ConnectivityMeasures'</span>,{<span class="string">'dDTF08'</span>,<span class="string">'S'</span>},<span class="keyword">...</span>
0078                             <span class="string">'ConvertSpectrumToDecibels'</span>,true,<span class="keyword">...</span>
0079                             <span class="string">'VerbosityLevel'</span>,0},<span class="keyword">...</span>
0080                         <span class="string">'Validation'</span>,[] <span class="keyword">...</span>
0081                         },@onl_siftpipeline,<span class="string">'Connectivity extraction options.'</span>), <span class="keyword">...</span>
0082                     arg_subtoggle({<span class="string">'lambdaSelection'</span>,<span class="string">'RegularizationParameterSelection'</span>},[], <span class="keyword">...</span>
0083                     { <span class="keyword">...</span>
0084                         arg_sub({<span class="string">'validationMetric'</span>,<span class="string">'ValidationMetric'</span>},<span class="keyword">...</span>
0085                                 {<span class="string">'plot'</span>,false, <span class="keyword">...</span>
0086                                  <span class="string">'verb'</span>,0, <span class="keyword">...</span>
0087                                  <span class="string">'checkConsistency'</span>,[],<span class="keyword">...</span>
0088                                  <span class="string">'checkStability'</span>,[], <span class="keyword">...</span>
0089                                  <span class="string">'checkResidualVariance'</span>,{}, <span class="keyword">...</span>
0090                                  <span class="string">'checkWhiteness'</span>,[]}, <span class="keyword">...</span>
0091                                 @est_validateMVAR,<span class="string">'Model validation options. Used for selection optimal lambda (VAR regularization).'</span>), <span class="keyword">...</span>
0092                         arg({<span class="string">'lambdaGrid'</span>,<span class="string">'LambdaGrid'</span>},logspace(log10(1e-5),log10(100),10),[],<span class="string">'Lambda grid. This is a row vector of possible lambda values to search over'</span>,<span class="string">'shape'</span>,<span class="string">'row'</span>) <span class="keyword">...</span>
0093                     },<span class="string">'Options for selecting optimal lambda. This only applies if you are using regularized model fitting methods that accept a &quot;lambda&quot; parameter'</span>), <span class="keyword">...</span>
0094                     arg({<span class="string">'valueFormat'</span>,<span class="string">'ValueFormat'</span>},<span class="string">'polar'</span>,{<span class="string">'complex'</span>,<span class="string">'components'</span>,<span class="string">'mixed'</span>,<span class="string">'magnitude'</span>,<span class="string">'sqrt-magnitude'</span>,<span class="string">'log-magnitude'</span>,<span class="string">'phase'</span>,<span class="string">'polar'</span>},<span class="string">'Output value format. Formatting for partially complex-valued features. Mixed means as-is, components means to separate real and imaginary components (both as real), magnitude retains only the complex magnitude, phase retains only the phase, and polar retains both magnitude and phase as real numbers.'</span>), <span class="keyword">...</span>
0095                     arg({<span class="string">'featureShape'</span>,<span class="string">'FeatureShape'</span>},<span class="string">'[CCMxFT] (time/freq row sparsity matrix)'</span>,{<span class="string">'[CCFTMx1] (unstructured vector)'</span>,<span class="string">'[CxCxFxTxM] (5d tensor)'</span>,<span class="string">'[CCMxFT] (time/freq row sparsity matrix)'</span>,<span class="string">'[CCxFTM] (per-link column sparsity matrix)'</span>,<span class="string">'[CCxFT]_m1,..,[CCxFT]_mk (low-rank space/time structure, sparse methods)'</span>,<span class="string">'[FxT]_c11,..,[FxT]_cnn (low-rank time/freq structure, sparse links)'</span>,<span class="string">'[CxC]_ft1,..,[CxC]_ft2 (low-rank link structure, sparse time/freq)'</span>},<span class="string">'Feature tensor arrangement. Features can be arranged in tensor or matrix or block-diagonal matrix form - most useful with the DAL classifier.'</span>), <span class="keyword">...</span>
0096                     arg({<span class="string">'vectorizeFeatures'</span>,<span class="string">'VectorizeFeatures'</span>},true,[],<span class="string">'Vectorize feature tensors. This is for classifiers that cannot handle matrix or tensor-shaped features.'</span>), <span class="keyword">...</span>
0097                     arg({<span class="string">'logBias'</span>,<span class="string">'LogBias'</span>},1e-4,[],<span class="string">'Bias for logarithms. This is to shift connectivity values to a Gaussian distribution and also to prevent negative infinities from occurring.'</span>), <span class="keyword">...</span>
0098                     arg({<span class="string">'verb'</span>,<span class="string">'Verbosity'</span>,<span class="string">'verbosity'</span>},true,[],<span class="string">'Verbose output'</span>));
0099  
0100             <span class="keyword">if</span> g.lambdaSelection.arg_selection <span class="keyword">...</span>
0101                     &amp;&amp; g.lambdaSelection.validationMetric.checkWhiteness.arg_selection <span class="keyword">...</span>
0102                     &amp;&amp; length(g.lambdaSelection.validationMetric.checkWhiteness.whitenessCriteria)&gt;1
0103                 error(<span class="string">'BCILAB:ParadigmSIFT:MoreThanOneIC'</span>,<span class="string">'Only one WhitenessCriteria can be selected for ParadigmSIFT.'</span>); <span class="keyword">end</span>
0104             
0105             <span class="keyword">if</span> g.lambdaSelection.arg_selection <span class="keyword">...</span>
0106                  &amp;&amp; sum([g.lambdaSelection.validationMetric.checkConsistency.arg_selection <span class="keyword">...</span>
0107                     g.lambdaSelection.validationMetric.checkResidualVariance.arg_selection <span class="keyword">...</span>
0108                     g.lambdaSelection.validationMetric.checkStability.arg_selection <span class="keyword">...</span>
0109                     g.lambdaSelection.validationMetric.checkWhiteness.arg_selection]) &gt; 1
0110                 error(<span class="string">'BCILAB:ParadigmSIFT:MoreThanOneValidationMetric'</span>,<span class="string">'Only one validation metric (Whiteness,Stability,ResidualVariance, or Consistency) may be selected for ParadigmSIFT'</span>); <span class="keyword">end</span>
0111                 
0112             <span class="comment">% force window length and step size to match epoch length</span>
0113             model.siftPipelineConfig = g.connPipeline;
0114             
0115             continuous = self.make_continuous(g.signal);
0116             
0117             <span class="comment">% lambda selection.</span>
0118             <span class="comment">% Here we use one of validation metrics to select lambda</span>
0119             <span class="keyword">if</span> g.lambdaSelection.arg_selection
0120                 <span class="keyword">if</span> g.verb
0121                     fprintf(<span class="string">'Performing grid search for optimal lambda\n'</span>); <span class="keyword">end</span>
0122                 
0123                 <span class="comment">% fit model and perform validation</span>
0124                 connPipelineRange = g.connPipeline;
0125                 <span class="keyword">if</span> strcmpi(g.connPipeline.modeling.algorithm.arg_selection,<span class="string">'Group Lasso (ADMM)'</span>)
0126                     connPipelineRange.modeling.algorithm.admm_args.lambda = search(g.lambdaSelection.lambdaGrid);
0127                 <span class="keyword">else</span>
0128                     error(<span class="string">'Unknown modeling method %s. Disable lambda search and try again'</span>,g.connPipeline.modeling.algorithm.arg_selection);
0129                     <span class="comment">% FIXME: ADD ADDITIONAL CASES FOR OTHER ALGORITHMS...s</span>
0130                 <span class="keyword">end</span>
0131                 
0132                 [min_idx,all_inputs,all_outputs] = utl_gridsearch(<span class="string">'clauses'</span>,@onl_siftpipeline,connPipelineRange,<span class="string">'EEG'</span>,continuous,<span class="string">'connectivity'</span>,[],<span class="string">'validation'</span>,g.lambdaSelection.validationMetric); <span class="comment">%#ok&lt;ASGLU&gt;</span>
0133                 
0134                 <span class="comment">% pick optimal lambda</span>
0135                 <span class="keyword">if</span> g.lambdaSelection.validationMetric.checkConsistency.arg_selection
0136                     <span class="comment">% objective function (minimize) is mean percent</span>
0137                     <span class="comment">% consistency over epochs</span>
0138                     objFun = cellfun(@(x) x{1}.CAT.validation.PCstats.PC,all_outputs,<span class="string">'UniformOutput'</span>,false);
0139                     objFun = cellfun(@mean,objFun);
0140                 <span class="keyword">elseif</span> g.lambdaSelection.validationMetric.checkResidualVariance.arg_selection
0141                     <span class="comment">% objective function (minimize) is residual whiteness</span>
0142                     <span class="comment">% over epochs</span>
0143                     objFun = cellfun(@(x) x{1}.CAT.validation.residualstats.variance,all_outputs,<span class="string">'UniformOutput'</span>,false);
0144                     objFun = cellfun(@(x) mean(cell2mat(x)),objFun);
0145                 <span class="keyword">elseif</span> g.lambdaSelection.validationMetric.checkStability.arg_selection
0146                     <span class="comment">% objective function (minimize) is fraction of epochs</span>
0147                     <span class="comment">% with unstable VAR model</span>
0148                     objFun = cellfun(@(x) x{1}.CAT.validation.stabilitystats.stability,all_outputs,<span class="string">'UniformOutput'</span>,false);
0149                     objFun = 1-cellfun(@(x) nnz(x)/numel(x),objFun);
0150                 <span class="keyword">elseif</span> g.lambdaSelection.validationMetric.checkWhiteness.arg_selection
0151                     whitenessCriterion = lower(hlp_variableize(g.lambdaSelection.validationMetric.checkWhiteness.whitenessCriteria{1}));
0152                     <span class="comment">% objective function (minimize) is 1-pvalue where</span>
0153                     <span class="comment">% a sufficiently large pvalue indicates white residuals</span>
0154                     objFun = cellfun(@(x) x{1}.CAT.validation.whitestats.(whitenessCriterion).pval,all_outputs,<span class="string">'UniformOutput'</span>,false);
0155                     objFun = 1-cellfun(@mean,objFun);
0156                 <span class="keyword">end</span>
0157                 
0158                 <span class="comment">% get the min of the objective function and select lambda</span>
0159                 [min_val min_idx] = min(objFun); <span class="comment">%#ok&lt;NCOMMA&gt;</span>
0160                 optLambda = g.lambdaSelection.lambdaGrid(min_idx);
0161                 <span class="keyword">if</span> g.verb
0162                   fprintf(<span class="string">'Optimal lambda found. lambda=%05g; objFun(lambda)=%0.5g\n'</span>,optLambda,min_val); <span class="keyword">end</span>
0163                 
0164                 <span class="comment">% retrieve the configuration structure corresponding to the</span>
0165                 <span class="comment">% optimal lambda</span>
0166                 model.siftPipelineConfig.modeling = all_outputs{min_idx}{2}.modeling;
0167                 <span class="keyword">if</span> strcmpi(g.connPipeline.modeling.algorithm.arg_selection,<span class="string">'Group Lasso (ADMM)'</span>)
0168                     model.siftPipelineConfig.modeling.algorithm.admm_args.lambda = optLambda;
0169                 <span class="keyword">end</span>
0170             <span class="keyword">end</span>
0171             model.valueFormat = g.valueFormat;
0172             model.featureShape = g.featureShape;
0173             model.vectorizeFeatures = g.vectorizeFeatures;
0174             model.logBias = g.logBias;
0175             model.args = g;
0176             
0177             <span class="comment">% run feature extraction for a short signal to get shape information</span>
0178             [print_output,tmpsignal] = evalc(<span class="string">'pop_select(g.signal,''trial'',1:min(3,g.signal.trials))'</span>); <span class="comment">%#ok&lt;ASGLU&gt;</span>
0179             <span class="keyword">if</span> ~strcmp(g.featureShape,<span class="string">'[CCFTMx1] (unstructured vector)'</span>)                
0180                 [dummy,model.shape] = self.feature_extract(tmpsignal,model); <span class="keyword">end</span> <span class="comment">%#ok&lt;ASGLU&gt;</span>
0181         <span class="keyword">end</span>
0182         
0183         <a name="_sub3" href="#_subfunctions" class="code">function [features,shape] = feature_extract(self,signal,featuremodel)</a>
0184             hlp_microcache(<span class="string">'conn'</span>,<span class="string">'max_key_size'</span>,2^30,<span class="string">'max_result_size'</span>,2^30);
0185             <span class="comment">% pre-calculate the placement indices within each epoch</span>
0186             winStartIdx = 1 : round(featuremodel.siftPipelineConfig.modeling.winstep*signal.srate) : signal.pnts - ceil(featuremodel.siftPipelineConfig.modeling.winlen * signal.srate);
0187             <span class="comment">% calculate placement indices across all epochs (after make_continuous)</span>
0188             winStartIdx = 1 + bsxfun(@plus,winStartIdx'-1, (0:signal.trials-1)*signal.pnts);
0189             featuremodel.siftPipelineConfig.modeling.winStartIdx = winStartIdx(:);
0190             
0191             <span class="comment">% extract connectivity features per epoch</span>
0192             EEG = hlp_microcache(<span class="string">'conn'</span>,@onl_siftpipeline,featuremodel.siftPipelineConfig,<span class="string">'EEG'</span>,self.make_continuous(signal));
0193             rawfeatures = cellfun(@(connmethod) EEG.CAT.Conn.(connmethod), <span class="keyword">...</span>
0194                 featuremodel.siftPipelineConfig.connectivity.connmethods, <span class="keyword">...</span>
0195                 <span class="string">'UniformOutput'</span>,false);
0196             
0197             <span class="comment">% reshape them to separate time points from trials {CxCxFxTxN, CxCxFxTxN, ...}</span>
0198             <span class="keyword">for</span> m=1:length(rawfeatures)
0199                 [C,C2,F,TN] = size(rawfeatures{m});
0200                 rawfeatures{m} = reshape(rawfeatures{m},C,C2,F,[],signal.trials);
0201             <span class="keyword">end</span>
0202             
0203             <span class="comment">% combine into single tensor: CxCxFxTxMxN</span>
0204             features = permute(cat(6,rawfeatures{:}),[1,2,3,4,6,5]);
0205             [C,C2,F,T,M,N] = size(features);
0206             <span class="keyword">if</span> C2 ~= C || N ~= signal.trials
0207                 error(<span class="string">'Unexpected feature shape.'</span>); <span class="keyword">end</span>
0208             
0209             <span class="comment">% reshape into desired form (note: all arrays are implicitly xN)</span>
0210             <span class="keyword">switch</span> featuremodel.featureShape
0211                 <span class="keyword">case</span> <span class="string">'[CxCxFxTxM] (5d tensor)'</span>
0212                     shape = [C,C,F,T,M];
0213                     <span class="keyword">if</span> ~isequal([shape N],size(features))
0214                         error(<span class="string">'Unexpected feature shape.'</span>); <span class="keyword">end</span>
0215                 <span class="keyword">case</span> <span class="string">'[CCMxFT] (time/freq row sparsity matrix)'</span>
0216                     features = reshape(permute(features,[1 2 5 3 4 6]),[C*C*M,F*T,N]);
0217                     shape = [C*C*M,F*T];
0218                     <span class="keyword">if</span> ~isequal([shape N],size(features))
0219                         error(<span class="string">'Unexpected feature shape.'</span>); <span class="keyword">end</span>
0220                 <span class="keyword">case</span> <span class="string">'[CCxFTM] (per-link column sparsity matrix)'</span>
0221                     features = reshape(permute(features,[1 2 3 4 5 6]),[C*C,F*T*M,N]);
0222                     shape = [C*C,F*T*M];
0223                     <span class="keyword">if</span> ~isequal([shape N],size(features))
0224                         error(<span class="string">'Unexpected feature shape.'</span>); <span class="keyword">end</span>
0225                 <span class="keyword">case</span> <span class="string">'[CCxFT]_m1,..,[CCxFT]_mk (low-rank space/time structure, sparse methods)'</span>
0226                     features = reshape(permute(features,[1 2 3 4 5 6]),[C*C,F*T*M,N]);
0227                     shape = repmat([C*C,F*T],M,1);
0228                 <span class="keyword">case</span> <span class="string">'[FxT]_c11,..,[FxT]_cnn (low-rank time/freq structure, sparse links)'</span>
0229                     features = reshape(permute(features,[3 4 1 2 5 6]),[F*T,C*C*M,N]);
0230                     shape = repmat([F,T],C*C*M,1);
0231                 <span class="keyword">case</span> <span class="string">'[CxC]_ft1,..,[CxC]_ft2 (low-rank link structure, sparse time/freq)'</span>
0232                     features = reshape(permute(features,[1 2 3 4 5 6]),[C*C,F*T*M,N]);
0233                     shape = repmat([C,C],F*T*M,1);
0234                 <span class="keyword">case</span> <span class="string">'[CCFTMx1] (unstructured vector)'</span>
0235                     shape = [C*C*F*T*M,1];
0236                 <span class="keyword">otherwise</span>
0237                     error(<span class="string">'Unrecognized FeatureShape selected.'</span>);
0238             <span class="keyword">end</span>
0239             
0240             <span class="comment">% apply value formatting</span>
0241             <span class="keyword">switch</span> featuremodel.valueFormat
0242                 <span class="keyword">case</span> <span class="string">'complex'</span>
0243                     features = complex(features);
0244                 <span class="keyword">case</span> <span class="string">'mixed'</span>
0245                     <span class="comment">% nothing to do</span>
0246                 <span class="keyword">case</span> <span class="string">'magnitude'</span>
0247                     features = abs(features);
0248                 <span class="keyword">case</span> <span class="string">'sqrt-magnitude'</span>
0249                     features = sqrt(abs(features));
0250                 <span class="keyword">case</span> <span class="string">'log-magnitude'</span>
0251                     features = log(featuremodel.logBias+abs(features));
0252                 <span class="keyword">case</span> <span class="string">'phase'</span>
0253                     features = angle(features);
0254                     <span class="comment">% these two cases will double the first shape parameter for each block</span>
0255                 <span class="keyword">case</span> <span class="string">'components'</span>
0256                     <span class="comment">% components are expanded along the first dimension</span>
0257                     features = permute(cat(ndims(features)+1,real(features),imag(features)),[ndims(features)+1,1:ndims(features)]);
0258                     shape(:,1) = shape(:,1)*2;
0259                 <span class="keyword">case</span> <span class="string">'polar'</span>
0260                     <span class="comment">% components are expanded along the first dimension</span>
0261                     features = permute(cat(ndims(features)+1,abs(features),angle(features)),[ndims(features)+1,1:ndims(features)]);
0262                     shape(:,1) = shape(:,1)*2;
0263                 <span class="keyword">otherwise</span>
0264                     error([<span class="string">'Unsupported value format: '</span> featuremodel.valueFormat]);
0265             <span class="keyword">end</span>
0266             
0267             <span class="comment">% do final vectorization if desired</span>
0268             <span class="keyword">if</span> featuremodel.vectorizeFeatures
0269                 features = reshape(features,[],signal.trials)'; <span class="keyword">end</span>
0270         <span class="keyword">end</span>
0271         
0272         <a name="_sub4" href="#_subfunctions" class="code">function visualize_model(self,parent,featuremodel,predictivemodel,varargin) </a><span class="comment">%#ok&lt;*INUSD&gt;</span>
0273             hlp_varargin2struct(varargin,<span class="string">'signed'</span>,true,<span class="string">'reordering'</span>,[],<span class="string">'smoothing_kernel'</span>,[]);
0274             reordering= [1 2 4 8 5 6 3 7 9];
0275             <span class="keyword">global</span> weights;
0276             <span class="keyword">global</span> weights_ord;
0277             fs = featuremodel.shape;
0278             <span class="comment">% get weights and featureshape</span>
0279             w = predictivemodel.model.w; 
0280             <span class="keyword">if</span> numel(w) == prod(fs)+1
0281                 w = w(1:end-1); <span class="keyword">end</span>
0282             <span class="comment">% reshape into tensor</span>
0283             M = ((reshape(w,fs))); 
0284             <span class="comment">% reverse frequency axis for plotting</span>
0285             M = M(:,:,end:-1:1,:); 
0286             <span class="keyword">if</span> ~isempty(smoothing_kernel)
0287                 M = filter(smoothing_kernel/norm(smoothing_kernel),1,M,[],3);
0288                 M = filter(smoothing_kernel/norm(smoothing_kernel),1,M,[],4);
0289             <span class="keyword">end</span>
0290             weights = M;
0291             M = M(reordering,reordering,:,:);
0292             weights_ord = M;
0293             <span class="comment">% add padding</span>
0294             M(:,:,end+1,:)=max(abs(M(:)));
0295             M(:,:,:,end+1)=max(abs(M(:)));            
0296             <span class="comment">% reorder for plotting</span>
0297             N = reshape(permute(M,[3,1,4,2,5]),fs(1)*(fs(3)+1),fs(2)*(fs(4)+1),[]);
0298             <span class="comment">% plot</span>
0299             chns = featuremodel.siftPipelineConfig.channels;
0300             <span class="keyword">if</span> signed
0301                 imagesc(N,<span class="string">'XData'</span>,[0.5 length(chns)+0.5],<span class="string">'YData'</span>,[0.5 length(chns)+0.5]);
0302                 caxis([-max(abs(N(:))) max(abs(N(:)))])
0303             <span class="keyword">else</span>
0304                 imagesc(abs(N),<span class="string">'XData'</span>,[0.5 length(chns)+0.5],<span class="string">'YData'</span>,[0.5 length(chns)+0.5]);
0305             <span class="keyword">end</span>
0306             colorbar;
0307             title(<span class="string">'Absolute model weights across component pairs in time/frequency.'</span>);            
0308             xlabel(<span class="string">'From Component'</span>);
0309             set(gca,<span class="string">'XTick'</span>,1:length(chns),<span class="string">'XTickLabel'</span>,chns);
0310             set(gca,<span class="string">'YTick'</span>,1:length(chns),<span class="string">'YTickLabel'</span>,chns);
0311             ylabel(<span class="string">'To Component'</span>);
0312         <span class="keyword">end</span>
0313 
0314         <a name="_sub5" href="#_subfunctions" class="code">function layout = dialog_layout_defaults(self)</a>
0315             <span class="comment">% define the default configuration dialog layout</span>
0316             layout = {<span class="string">'SignalProcessing.Resampling.SamplingRate'</span>, <span class="keyword">...</span>
0317                 <span class="string">''</span>, <span class="keyword">...</span>
0318                 <span class="string">'SignalProcessing.DataCleaning.DataSetting'</span>, <span class="keyword">...</span>
0319                 <span class="string">''</span>, <span class="keyword">...</span>
0320                 <span class="string">'SignalProcessing.SourceLocalization.InverseMethod'</span>, <span class="keyword">...</span>
0321                 <span class="string">''</span>, <span class="keyword">...</span>
0322                 <span class="string">'SignalProcessing.SourceLocalization.AtlasROI'</span>, <span class="keyword">...</span>
0323                 <span class="string">''</span>, <span class="keyword">...</span>
0324                 <span class="string">'SignalProcessing.EpochExtraction'</span>, <span class="keyword">...</span>
0325                 <span class="string">''</span>, <span class="keyword">...</span>
0326                 <span class="string">'Prediction.FeatureExtraction.ConnectivityPipeline.Modeling.Algorithm.arg_selection'</span>, <span class="keyword">...</span>
0327                 <span class="string">''</span>, <span class="keyword">...</span>
0328                 <span class="string">'Prediction.FeatureExtraction.ConnectivityPipeline.Connectivity.ConnectivityMeasures'</span>, <span class="keyword">...</span>
0329                 <span class="string">'Prediction.FeatureExtraction.RegularizationParameterSelection.LambdaGrid'</span>, <span class="keyword">...</span>
0330                 <span class="string">''</span>,<span class="keyword">...</span>
0331                 <span class="string">'Prediction.FeatureExtraction.ValueFormat'</span>, <span class="keyword">...</span>
0332                 <span class="string">'Prediction.FeatureExtraction.VectorizeFeatures'</span>, <span class="keyword">...</span>
0333                 <span class="string">''</span>, <span class="keyword">...</span>
0334                 <span class="string">'Prediction.MachineLearning.Learner'</span>};
0335         <span class="keyword">end</span>
0336                 
0337         <a name="_sub6" href="#_subfunctions" class="code">function tf = needs_voting(self)</a>
0338             <span class="comment">% standard CSP requires voting to handle more than 2 classes</span>
0339             tf = true; 
0340         <span class="keyword">end</span>
0341         
0342         <a name="_sub7" href="#_subfunctions" class="code">function sig = make_continuous(self,sig)</a>
0343             <span class="comment">% turn an epoched signal into a continuous one</span>
0344             <span class="keyword">if</span> sig.trials ~= 1
0345                 <span class="comment">% epoched dataset... reshape it</span>
0346                 sig.data = sig.data(:,:);
0347                 <span class="keyword">if</span> isfield(sig,<span class="string">'srcpot'</span>) &amp;&amp; ~isempty(sig.srcpot)
0348                     sig.srcpot = sig.srcpot(:,:); <span class="keyword">end</span>
0349                 <span class="keyword">if</span> isfield(sig,<span class="string">'icaact'</span>) &amp;&amp; ~isempty(sig.icaact)
0350                     sig.icaact = sig.icaact(:,:); <span class="keyword">end</span>
0351                 [sig.chns,sig.pnts,sig.trials] = size(sig.data);
0352                 sig.epoch = [];
0353                 sig.event = [];
0354             <span class="keyword">end</span>
0355         <span class="keyword">end</span>
0356         
0357     <span class="keyword">end</span>
0358 <span class="keyword">end</span>
0359</pre></div>
<hr><address>Generated on Tue 20-Aug-2013 03:44:10 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>