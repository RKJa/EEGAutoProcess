<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of ParadigmMTCSP</title>
  <meta name="keywords" content="ParadigmMTCSP">
  <meta name="description" content="">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">code</a> &gt; <a href="index.html">paradigms</a> &gt; ParadigmMTCSP.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for code/paradigms&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>ParadigmMTCSP
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong></strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="ParadigmDataflowSimplified.html" class="code" title="">ParadigmDataflowSimplified</a>	</li><li><a href="ParadigmMTCSP.html" class="code" title="">ParadigmMTCSP</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="ParadigmMTCSP.html" class="code" title="">ParadigmMTCSP</a>	</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function defaults = preprocessing_defaults(self)</a></li><li><a href="#_sub2" class="code">function defaults = machine_learning_defaults(self)</a></li><li><a href="#_sub3" class="code">function model = feature_adapt(self,varargin)</a></li><li><a href="#_sub4" class="code">function features = feature_extract(self,signal,featuremodel)</a></li><li><a href="#_sub5" class="code">function visualize_model(self,parent,featuremodel,predictivemodel,varargin)</a></li><li><a href="#_sub6" class="code">function layout = dialog_layout_defaults(self)</a></li><li><a href="#_sub7" class="code">function tf = needs_voting(self)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 classdef <a href="ParadigmMTCSP.html" class="code" title="">ParadigmMTCSP</a> &lt; <a href="ParadigmDataflowSimplified.html" class="code" title="">ParadigmDataflowSimplified</a>
0002     <span class="comment">% Experimental paradigm for all-frequency Common Spatial Patterns.</span>
0003     <span class="comment">%</span>
0004     <span class="comment">% The basic idea is to calculate CSP for each covariance matrix in the cross-spectrum,</span>
0005     <span class="comment">% and to use multi-taper spectral estimation to ensure an optimal tradeoff between</span>
0006     <span class="comment">% spectral precision and estimation noise. The default classifier is sparse logistic</span>
0007     <span class="comment">% regression with elastic-net penalty.</span>
0008     <span class="comment">%</span>
0009     <span class="comment">% This paradigm also implements a second approach in which the cross-spectrum is not spatially</span>
0010     <span class="comment">% filtered but directly submitted to the classifier (Disciplined Cross-Spectral Regression).</span>
0011     <span class="comment">%</span>
0012     <span class="comment">% Name:</span>
0013     <span class="comment">%   Multi-Taper CSP</span>
0014     <span class="comment">%</span>
0015     <span class="comment">%                           Christian Kothe, Swartz Center for Computational Neuroscience, UCSD</span>
0016     <span class="comment">%                           2013-04-26</span>
0017     
0018     methods
0019       
0020         <a name="_sub0" href="#_subfunctions" class="code">function defaults = preprocessing_defaults(self)</a>
0021             <span class="comment">% define the default pre-processing parameters of this paradigm</span>
0022             defaults = {<span class="string">'FIRFilter'</span>,{[0.5 1],<span class="string">'highpass'</span>}, <span class="string">'EpochExtraction'</span>,[0.5 3.5],<span class="string">'Resampling'</span>,200};
0023         <span class="keyword">end</span>
0024         
0025         <a name="_sub1" href="#_subfunctions" class="code">function defaults = machine_learning_defaults(self)</a>
0026             defaults = {<span class="string">'logreg'</span>,<span class="string">'variant'</span>,{<span class="string">'lars'</span>,<span class="string">'ElasticMixing'</span>,0.25}};
0027         <span class="keyword">end</span>
0028                 
0029         <a name="_sub2" href="#_subfunctions" class="code">function model = feature_adapt(self,varargin)</a>
0030             <span class="comment">% adapt a feature representation using the CSP algorithm</span>
0031             args = arg_define(varargin, <span class="keyword">...</span>
0032                 arg_norep(<span class="string">'signal'</span>), <span class="keyword">...</span>
0033                 arg({<span class="string">'timewnds'</span>,<span class="string">'TimeWindows'</span>},[],[],<span class="string">'Time windows of interest. Matrix containing one row for the start and end of each time window for which CSP patterns shall be computed. Values in seconds. If both this and the freqwnds parameter are non-empty, they should have the same number of rows.'</span>), <span class="keyword">...</span>
0034                 arg({<span class="string">'winfunc'</span>,<span class="string">'WindowFunction'</span>},<span class="string">'rect'</span>,{<span class="string">'bartlett'</span>,<span class="string">'barthann'</span>,<span class="string">'blackman'</span>,<span class="string">'blackmanharris'</span>,<span class="string">'flattop'</span>,<span class="string">'gauss'</span>,<span class="string">'hamming'</span>,<span class="string">'hann'</span>,<span class="string">'kaiser'</span>,<span class="string">'lanczos'</span>,<span class="string">'nuttall'</span>,<span class="string">'rect'</span>,<span class="string">'triang'</span>},<span class="string">'Type of window function. Typical choices are rect (rectangular), hann, gauss, blackman and kaiser.'</span>),<span class="keyword">...</span>
0035                 arg({<span class="string">'winparam'</span>,<span class="string">'WindowParameter'</span>,<span class="string">'param'</span>},[],[],<span class="string">'Parameter of the window function. This is mandatory for cheb, kaiser and tukey and optional for some others.'</span>,<span class="string">'shape'</span>,<span class="string">'scalar'</span>), <span class="keyword">...</span>
0036                 arg_sub({<span class="string">'spectral_estimation'</span>,<span class="string">'SpectralEstimation'</span>},{},@utl_calc_crossspec, <span class="string">'Spectral estimation parameters.'</span>), <span class="keyword">...</span>
0037                 arg({<span class="string">'patterns'</span>,<span class="string">'PatternPairs'</span>},uint32(3),[],<span class="string">'CSP patterns per frequency (times two).'</span>), <span class="keyword">...</span>
0038                 arg({<span class="string">'whycsp'</span>,<span class="string">'SkipCSP'</span>,<span class="string">'WhyCSP'</span>},false,[],<span class="string">'Classify cross-spectrum directly. This results in much higher-dimensional features, but can be approached with appropriately regularized classifiers (see ml_trainproximal).'</span>), <span class="keyword">...</span>
0039                 arg({<span class="string">'normalize_spectrum'</span>,<span class="string">'NormalizeSpectrum'</span>},false,[],<span class="string">'Normalize the spectrum. Recommended if using sophisticated regularized classifiers.'</span>), <span class="keyword">...</span>
0040                 arg({<span class="string">'vectorize_features'</span>,<span class="string">'VectorizeFeatures'</span>},true,[],<span class="string">'Vectorize the features. For compatibility with basic classifiers.'</span>));
0041             
0042             <span class="keyword">if</span> args.signal.nbchan == 1
0043                 error(<span class="string">'Multi-taper CSP does intrinsically not support single-channel data (it is a spatial filter).'</span>); <span class="keyword">end</span>
0044             <span class="keyword">if</span> args.signal.nbchan &lt; args.patterns
0045                 error(<span class="string">'Multi-taper CSP prefers to work on at least as many channels as you request output patterns. Please reduce the number of pattern pairs.'</span>); <span class="keyword">end</span>
0046             <span class="keyword">if</span> isempty(args.timewnds)
0047                 args.timewnds = struct(); <span class="keyword">end</span>
0048             <span class="keyword">if</span> args.whycsp
0049                 <span class="comment">% shortcut</span>
0050                 <span class="keyword">for</span> w = size(args.timewnds,1):-1:1
0051                     time_args{w} = arg_report(<span class="string">'vals'</span>,@flt_window,{<span class="string">'time'</span>,{args.timewnds(w,:),args.winfunc,args.winparam}}); <span class="keyword">end</span>
0052                 model = struct(<span class="string">'spec_args'</span>,{args.spectral_estimation}, <span class="string">'time_args'</span>,{time_args},<span class="string">'chanlocs'</span>,{args.signal.chanlocs},<span class="string">'vectorize_features'</span>,{args.vectorize_features},<span class="string">'whycsp'</span>,{args.whycsp},<span class="string">'normalize_spectrum'</span>,{args.normalize_spectrum});
0053             <span class="keyword">else</span>
0054                 covar = {}; mean_covar = {}; weighted_covar = {};
0055                 <span class="comment">% for each time window...</span>
0056                 <span class="keyword">for</span> w = size(args.timewnds,1):-1:1
0057                     <span class="keyword">if</span> length(unique([args.signal.event.target]))&gt;2
0058                         <span class="comment">% SPoC version</span>
0059                         time_args{w} = arg_report(<span class="string">'vals'</span>,@flt_window,{<span class="string">'time'</span>,{args.timewnds(w,:),args.winfunc,args.winparam}});
0060                         <span class="comment">% calc weighted and average cross-spectra</span>
0061                         [mean_covar{w},weighted_covar{w}] = hlp_diskcache(<span class="string">'featuremodels'</span>,@utl_calc_crossspec,args.spectral_estimation,<span class="string">'sum_weights'</span>,[args.signal.epoch.target],<span class="string">'signal'</span>,exp_eval_optimized(flt_window(<span class="string">'signal'</span>,args.signal,time_args{w})));
0062                         mean_covar{w}(~isfinite(mean_covar{w})) = 0; weighted_covar{w}(~isfinite(weighted_covar{w})) = 0;
0063                         <span class="comment">% calculate spatial filters for each frequency</span>
0064                         <span class="keyword">for</span> f=size(mean_covar{w},1):-1:1
0065                             [V,D] = eig(squeeze(weighted_covar{w}(f,:,:)),squeeze(mean_covar{w,1}(f,:,:))); <span class="comment">%#ok&lt;NASGU&gt;</span>
0066                             P = inv(V);
0067                             <span class="comment">% retain k best filters/patterns at both ends of the eigenvalue spectrum</span>
0068                             filters(w,f,:,:) = real(V(:,[1:args.patterns end-args.patterns+1:end]));
0069                             patterns(w,f,:,:) = real(P([1:args.patterns end-args.patterns+1:end],:))';
0070                         <span class="keyword">end</span>
0071                     <span class="keyword">else</span>
0072                         <span class="comment">% CSP version</span>
0073                         <span class="keyword">for</span> k=1:2
0074                             subset = exp_eval_optimized(set_picktrials(args.signal,<span class="string">'rank'</span>,k));
0075                             <span class="comment">% pre-parse arguments for flt_window and flt_spectrum (for fast subsequent online use)</span>
0076                             time_args{w} = arg_report(<span class="string">'vals'</span>,@flt_window,{<span class="string">'time'</span>,{args.timewnds(w,:),args.winfunc,args.winparam}});
0077                             <span class="comment">% calc cross-spectrum for the given windowed data subset</span>
0078                             covar{w,k} = hlp_diskcache(<span class="string">'featuremodels'</span>,@utl_calc_crossspec,args.spectral_estimation,<span class="string">'signal'</span>,exp_eval_optimized(flt_window(<span class="string">'signal'</span>,subset,time_args{w})));
0079                             covar{w,k}(~isfinite(covar{w,k})) = 0;
0080                         <span class="keyword">end</span>
0081                         <span class="comment">% solve a CSP instance for each frequency</span>
0082                         <span class="keyword">for</span> f=size(covar{w,1},1):-1:1
0083                             [V,D] = eig(squeeze(covar{w,1}(f,:,:)),squeeze(covar{w,1}(f,:,:)+covar{w,2}(f,:,:))); <span class="comment">%#ok&lt;NASGU&gt;</span>
0084                             P = inv(V);
0085                             filters(w,f,:,:) = real(V(:,[1:args.patterns end-args.patterns+1:end]));
0086                             patterns(w,f,:,:) = real(P([1:args.patterns end-args.patterns+1:end],:))';
0087                         <span class="keyword">end</span>                
0088                     <span class="keyword">end</span>
0089                 <span class="keyword">end</span>
0090                 model = struct(<span class="string">'filters'</span>,{filters},<span class="string">'patterns'</span>,{patterns},<span class="string">'time_args'</span>,{time_args},<span class="string">'spec_args'</span>,{args.spectral_estimation}, <span class="string">'covar'</span>,{covar}, <span class="string">'mean_covar'</span>,{mean_covar}, <span class="string">'weighted_covar'</span>,{weighted_covar}, <span class="string">'chanlocs'</span>,{args.signal.chanlocs},<span class="string">'vectorize_features'</span>,{args.vectorize_features},<span class="string">'whycsp'</span>,{args.whycsp},<span class="string">'normalize_spectrum'</span>,{args.normalize_spectrum});
0091             <span class="keyword">end</span>
0092             <span class="keyword">global</span> tracking; <span class="comment">%#ok&lt;TLEV&gt;</span>
0093             tracking.inspection.signal = args.signal;
0094             tracking.inspection.chanlocs = args.signal.chanlocs;
0095         <span class="keyword">end</span>
0096                 
0097         <a name="_sub3" href="#_subfunctions" class="code">function features = feature_extract(self,signal,featuremodel)</a>
0098             <span class="keyword">for</span> w = length(featuremodel.time_args):-1:1
0099                 <span class="comment">% extract time window</span>
0100                 wnd = exp_eval_optimized(flt_window(<span class="string">'signal'</span>,signal,featuremodel.time_args{w}));
0101                 <span class="comment">% extract cross-spectral features (note: gigantic!)</span>
0102                 <span class="keyword">if</span> featuremodel.whycsp
0103                     <span class="comment">% W x F x C x C x T</span>
0104                     features(w,:,:,:,:) = utl_calc_crossspec(featuremodel.spec_args,<span class="string">'signal'</span>,wnd,<span class="string">'feature_filters'</span>,false);
0105                     <span class="keyword">if</span> featuremodel.normalize_spectrum
0106                         nfreqs = size(features,2);
0107                         freqs = featuremodel.spec_args.freqwnd;
0108                         freqs = freqs(1):(freqs(2)-freqs(1))/(nfreqs-1):freqs(2);
0109                         features = bsxfun(@times,features,max(1,freqs));
0110                     <span class="keyword">end</span>
0111                 <span class="keyword">else</span>
0112                     <span class="comment">% F x W x P x T</span>
0113                     <span class="keyword">if</span> onl_isonline
0114                         features(:,w,:,:) = utl_calc_crossspec(featuremodel.spec_args,<span class="string">'signal'</span>,wnd,<span class="string">'feature_filters'</span>,squeeze(featuremodel.filters(w,:,:,:)));
0115                     <span class="keyword">else</span>
0116                         features(:,w,:,:) = hlp_diskcache(<span class="string">'general'</span>,@utl_calc_crossspec,featuremodel.spec_args,<span class="string">'signal'</span>,wnd,<span class="string">'feature_filters'</span>,squeeze(featuremodel.filters(w,:,:,:)));
0117                     <span class="keyword">end</span>
0118                     <span class="keyword">if</span> featuremodel.normalize_spectrum
0119                         nfreqs = size(features,1);
0120                         freqs = featuremodel.spec_args.freqwnd;
0121                         freqs = freqs(1):(freqs(2)-freqs(1))/(nfreqs-1):freqs(2);
0122                         features = bsxfun(@times,features,max(1,1./freqs'));
0123                     <span class="keyword">end</span>                    
0124                 <span class="keyword">end</span>
0125             <span class="keyword">end</span>
0126             <span class="comment">% apply minimal conditioning to features</span>
0127             features = real(features);            
0128             features(~isfinite(features)) = 0;
0129             <span class="comment">% do final vectorization if desired</span>
0130             <span class="keyword">if</span> featuremodel.vectorize_features
0131                 features = reshape(features,[],signal.trials)'; <span class="keyword">end</span>
0132         <span class="keyword">end</span>
0133         
0134         <a name="_sub4" href="#_subfunctions" class="code">function visualize_model(self,parent,featuremodel,predictivemodel,varargin) </a><span class="comment">%#ok&lt;*INUSD&gt;</span>
0135             <span class="comment">% no visualization yet</span>
0136         <span class="keyword">end</span>
0137         
0138         <a name="_sub5" href="#_subfunctions" class="code">function layout = dialog_layout_defaults(self)</a>
0139             <span class="comment">% define the default configuration dialog layout</span>
0140             layout = {<span class="string">'SignalProcessing.Resampling.SamplingRate'</span>, <span class="string">'SignalProcessing.EpochExtraction'</span>, <span class="string">''</span>, <span class="keyword">...</span>
0141                 <span class="string">'Prediction.FeatureExtraction.TimeWindows'</span>,<span class="string">'Prediction.FeatureExtraction.WindowFunction'</span>, <span class="string">''</span>, <span class="keyword">...</span>
0142                 <span class="string">'Prediction.FeatureExtraction.SpectralEstimation.FrequencyRange'</span>, <span class="keyword">...</span>
0143                 <span class="string">'Prediction.FeatureExtraction.SpectralEstimation.TimeBandwidth'</span>, <span class="keyword">...</span>
0144                 <span class="string">'Prediction.FeatureExtraction.SpectralEstimation.SubsampleSpectrum'</span>, <span class="keyword">...</span>
0145                 <span class="string">'Prediction.FeatureExtraction.SpectralEstimation.RobustEstimation'</span>, <span class="string">''</span> <span class="keyword">...</span>
0146                 <span class="string">'Prediction.FeatureExtraction.PatternPairs'</span>, <span class="string">'Prediction.FeatureExtraction.VectorizeFeatures'</span>, <span class="string">''</span>, <span class="keyword">...</span>
0147                 <span class="string">'Prediction.MachineLearning.Learner'</span>};
0148         <span class="keyword">end</span>
0149         
0150         <a name="_sub6" href="#_subfunctions" class="code">function tf = needs_voting(self)</a>
0151             tf = false;
0152         <span class="keyword">end</span>
0153     <span class="keyword">end</span>
0154 <span class="keyword">end</span>
0155</pre></div>
<hr><address>Generated on Tue 20-Aug-2013 03:44:10 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>